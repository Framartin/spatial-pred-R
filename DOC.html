<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Extending Predictions from Spatial Econometric Models on R</title>
<!-- 2014-04-17 jeu. 20:33 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jean-Sauveur AY \\ \lt[[mailto:jsay.site@gmail.com][jsay.site@gmail.com]]jsay.site@gmail.com\gt \and Raja CHAKIR\\ \lt[[mailto:chakir@grignon.inra.fr][chakir@grignon.inra.fr]]chakir@grignon.inra.fr\gt\\ \and Julie LE GALLO\\ \lt[[mailto:jlegallo@univ-fcomte.fr][jlegallo@univ-fcomte.fr]]jlegallo@univ-fcomte.fr\gt" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />

<script type="text/javascript" src="http://thomasf.github.io/solarized-css/org-info.min.js">
/**
 *
 * @source: http://thomasf.github.io/solarized-css/org-info.min.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://thomasf.github.io/solarized-css/org-info.min.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://thomasf.github.io/solarized-css/org-info.min.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "5");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Extending Predictions from Spatial Econometric Models on R</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Theoretical Framework</a>
<ul>
<li><a href="#sec-1-1">1.1. Spatial econometric models</a></li>
<li><a href="#sec-1-2">1.2. Implementing predictions</a></li>
<li><a href="#sec-1-3">1.3. A taxonomy of spatial predictions</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Current function from <code>spdep</code></a></li>
<li><a href="#sec-3">3. The <code>sppred</code> extension</a>
<ul>
<li><a href="#sec-3-1">3.1. General Structure</a></li>
<li><a href="#sec-3-2">3.2. Predictors conditioned on X, W</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. exogenous predictor</a></li>
<li><a href="#sec-3-2-2">3.2.2. endogenous predictor</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. Predictors conditioned on X, W, y</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. biased predictors</a></li>
<li><a href="#sec-3-3-2">3.3.2. BLUP LSP</a></li>
<li><a href="#sec-3-3-3">3.3.3. BLUP KP2</a></li>
<li><a href="#sec-3-3-4">3.3.4. BLUP KP3</a></li>
</ul>
</li>
<li><a href="#sec-3-4">3.4. Predictors conditioned by hand</a></li>
</ul>
</li>
<li><a href="#sec-4">4. How it works</a>
<ul>
<li><a href="#sec-4-1">4.1. Choosing a type of predictor</a></li>
<li><a href="#sec-4-2">4.2. Specifying</a></li>
<li><a href="#sec-4-3">4.3. General structure, usual checks, and IS predictions</a></li>
<li><a href="#sec-4-4">4.4. The predictors 1 for OS predictions</a></li>
</ul>
</li>
<li><a href="#sec-5">5. The <code>boston</code> example</a>
<ul>
<li><a href="#sec-5-1">5.1. Subset the dataset</a></li>
<li><a href="#sec-5-2">5.2. Estimating the models</a></li>
<li><a href="#sec-5-3">5.3. Predicting</a>
<ul>
<li><a href="#sec-5-3-1">5.3.1. Inefficient predictors</a></li>
<li><a href="#sec-5-3-2">5.3.2. BLUP predictors</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-6">6. Summary</a>
<ul>
<li><a href="#sec-6-1">6.1. Changes relative to <code>predict.sarlm</code></a></li>
<li><a href="#sec-6-2">6.2. About the intercept</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract">
<p>
This document presents an integrative framework to make predictions
from spatial autoregressive models [<a href="#COrd73">COrd73</a>,<a href="# COrd81"> COrd81</a>,<a href="# Anse88"> Anse88</a>]. It
also contains the corresponding <a href="http:www.r-project.org"><b>R</b> code</a> to implement the predictors
presented. The code is tangled into the <a href="./sppred.R"><code>sppred</code></a> function that
implements in particular the predictors from LeSage and Pace
(2004, 2008) and Kelejian and Prucha (2004) for a large number of
specifications of spatial autocorrelation from the <a href="http:cran.r-project.org/web/packages/spdep/index.html"><code>spdep</code> package</a>
(Bivand 2014). To use this code, save the file <a href="./sppred.R"><code>sppred</code></a> in your
working directory then submit <code>source("sppred.R")</code> to <b>R</b>. Some
examples on the <code>boston</code> data are also available at section XX. The
status of this work is actually under construction, comments are
welcome.<br  />
</p>

<p>
<b><code>STILL TODO</code></b> 
</p>
<ul class="org-ul">
<li>Code the variances and confidence intervals of predictors
</li>
<li>Code the weight matrix for ex-sample predictions
</li>
<li>Code the predictors for <code>sphet</code> and <code>splm</code> objects
</li>
</ul>

</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Theoretical Framework</a></li>
<li><a href="#sec-2">2. Current function from <code>spdep</code></a></li>
<li><a href="#sec-3">3. The <code>sppred</code> extension</a></li>
<li><a href="#sec-4">4. How it works</a></li>
<li><a href="#sec-5">5. The <code>boston</code> example</a></li>
<li><a href="#sec-6">6. Summary</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Theoretical Framework</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Spatial econometric models</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The particularity of spatial econometric models is the <i>ex ante</i>
specification of interdependence between statistical units,
typically from their spatial proximity.  Consequently, resulting
predictions not only depend on the variables of the target units
(i.e., the units for which we want to predict the outcome) but
potentially involve the entire set of both explanatory as well as
dependent variable sample data observations.  This implies that the
sample pattern of the outcomes or the residuals contains additional
information which may be used to modify the regression function so
as to reduce the prediction variance (Goldberger 1962). [<a href="#COrd73">COrd73</a>]</p>

<p>
The literature about predicting from spatial econometric models is
not actually unified, due to different modeling frameworks and
notations: see LeSage and Pace (2004, 2008) and Kelejian and Prucha
(2004).  A first contribution of this document is to unify the
different predictors proposed in the literature into an integrative
spatial econometric framework.  A second contribution is to present
the <b>R</b> function <code>sppred</code> that implements all the spatial
predictors and presents some empirical evidence on their relative
performance on a well-known dataset (<code>boston</code>, Bivand 2014).
</p>

<p>
We present analytically the available predictors from spatial
econometric models estimated on a sample of \(N\) spatial units. We
begin with the more general spatial autoregressive mixed
conditional (SMC) specification of the Cliff-Ord (1973, 1981) class
of homoscedastic models with exogenous covariates,<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

\begin{align}
y & = \alpha+ \rho Wy+X\beta+ WX\theta+ u\nonumber\\
u & = \lambda W u+ \varepsilon \;\;\mbox{ with }\;\; \varepsilon\sim \mathbf{N}(0, \sigma^2I_N)\nonumber
\end{align}

<p>
The term \(y\) is a \(N\times 1\) vector of the continuous outcome of
interest, \(X\) is a \(N\times K\) matrix of the \(K\) non-constant
covariates, and \(W\) is a \(N\times N\) full-rank spatial weight
matrix (see Anselin 1988). We limit ourselves to a same weight
matrix in the outcome and error equations, but formally nothing
requires this restriction. The unknown parameters (or vectors of
parameters) \(\alpha\), \(\rho\), \(\beta\), \(\theta\), \(\lambda\) and
\(\sigma\) grouped in \(\Theta\) have to be estimated, as the vector
\(\varepsilon\) of innovations. Classically, we assume that
\(\mbox{diag}(W)= 0\) and \(|\,\rho\,|\), \(|\,\lambda\,|< 1\). The
spatial weight matrix \(W\) does not need to be symmetric.
</p>

<p>
This form is sufficiently general that the spatial autoregressive
conditional (SAC) model can be recovered with \(\theta= 0\), the
spatial Durbin model (SDM) model with \(\lambda=0\), the spatial
autoregressive (SAR) model with \(\theta=\lambda=0\), the spatial X
model (SXM, also called Spatial Durban Error Model by LeSage and
Pace, 2009) with \(\rho=0\) and the spatial error model (SEM) can be
recovered with \(\rho=\theta= 0\). All these models can be estimated
by maximum likelihood through the functions <code>errorsarlm</code>,
<code>lagsarlm</code>, and <code>sacsarlm</code> of the <b>R</b> package <code>spdep</code> (Bivand,
2014).
</p>

<p>
For future reference, note that the general SMC model can be
reduced in \(y= (I-\rho W)^{-1}X\beta +(I-\rho W)^{-1}(I-\lambda
   W)^{-1}\varepsilon\), with a distribution that involves all of the
model parameters:
</p>

\begin{equation}
y\mid X, W, \Theta \sim \mathbf{N}(\mu, \sigma_{\varepsilon}^2\Sigma),
\end{equation}

<p>
with \(\mu=(I-\rho W)^{-1}X\beta\), and \(\Sigma= \big[(I-\rho
   W)(I-\lambda W)(I-\lambda W^\top)(I-\rho W^\top)\big]^{-1}\).
According to the literature, we consider hereafter that the set of
parameters \(\Theta\) is known with certainty.  This has the
advantage of simplifying notations by neglecting a source of
uncertainty that depends on the sample size.  Moreover, all the
parameters are estimated simultaneously and it makes no sens to
consider \(\Theta\) as partially known.  Hence, the predictors
presented are all conditioned by \(\Theta\), which is dropped from
conditioning sets for the sake of clarity. So its not the true BLUP
but an approximation.
</p>

<p>
Finally, note that geo-statistical models (Cressie 1990) usually
involve specifying spatial dependence through the error process
(like in SEM or SXM) as opposed to the spatial lag of the outcome
vector (like in SAR or SDM). Predicting from these error models
take a simpler form than autoregressive models and can be easily
recovered from the theoretical framework presented here. The
reverse is not true.
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Implementing predictions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Basically, we consider \(M\) target spatial units for which we want
to predict the values of the outcome \(y\).  These units may or may
not be included in the dataset used for the estimation of the
parameters. At this moment, it makes no differences and we
distinguish them only in the research interest of obtaining
predictions of \(y\).<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>  We discuss this point in more details at the
next subsection XX.
</p>

<p>
The available information set is crucial here, as each predictor is
formulated as a conditional expectation relative to it. 
</p>

<p>
. in terms of conditional expectation put the focus of
   the available information used to construct the predictors which is
   important for the transparency of the code. 
</p>

\begin{equation}
\tag{PRD.X}\mathbf{E}(y\mid X)= X \widehat{\beta}\nonumber
\end{equation}

\begin{equation}
\tag{PRD.WX}\mathbf{E}(y\mid X, W)= X\widehat{\beta}+ WX\widehat{\theta}
\end{equation}

\begin{equation}
\tag{PRD.KP1}\mathbf{E}(y\mid X, W)= (I_n-\rho W)^{-1} (X\widehat{\beta}+ WX\widehat{\theta})
\end{equation}

<p>
This correspond to KP1 but also the exogenous predictor of LSP. It
is the default predictor of the function <code>sppred</code>.
</p>

\begin{equation}
\tag{PRD4}\mathbf{E}(y\mid X, W, Wy)= \rho Wy+ X\widehat{\beta}+ WX\widehat{\theta}+ \lambda (Wy- X\beta- WX\theta)
\end{equation}

<p>
It is a bit strange but \(y\) cannot be recovered from \(W\) and
\(Wy\). KP analyses this predictor separately in KP4 and KP5 but such
a distinction is not necessary.  Since \(\mbox{diag}(W)=0\), \(W y\)
does not use individually the \(y_i\) to predict itself but needs
them all to predict the entire vector.
</p>

<p>
The bias of actual predictors come from the correlation between the
spatially lagged dependent variable and the error term. It is why
the use of best linear unbiased predictor (Golberger) is of
particular importance.
</p>

\begin{equation}
\tag{PRD5}\mathbf{E}(y\mid X, W, y_{IS})= (I_n-\rho W)^{-1} X\widehat{\beta}+ WX\widehat{\theta}
                                        + \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))
\end{equation}

<p>
The covariance can be simplified with precision matrix (Harville)
which do not necessitate the inversion of matrix:
\(\Omega_{21}\Omega_{11}^{-1}= \Psi_{21}\Psi_{11}^{-1}\). LSP also
present a leave-one-out (loo) specification of this predictor, that
is based on the same conditioning set, except that we consider the
predictions individually of each OS units indexed \(i\).
</p>

\begin{equation}
\tag{prdLSP}\mathbf{E}(y_i\mid X, W, y_{IS})= (I_n-\rho W)^{-1}X\widehat{\beta}+ WX\widehat{\theta}
                                            + \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))\label{prdLSP}
\end{equation}

<p>
This simplification comes from&#x2026;
</p>

\begin{equation}
\tag{prdKP2}\mathbf{E}(y_i\mid X, W, y_{IS})= \rho Wy+ X\widehat{\beta}+ WX\widehat{\theta} 
                                            +  \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))
\end{equation}

<p>
yopla
</p>

\begin{equation}
\tag{prdKP2}\mathbf{E}(y_i\mid X, W, y_{IS})= \rho Wy+ X\widehat{\beta}+ WX\widehat{\theta}
                                        + \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))
\end{equation}

<p>
If we put aside the differences in the conditional mean of the
exogenous part, this predictor <code>predKP2</code> is identical to <i>prdLSP</i>.
</p>


<p>
Can we still maintain the signal trend distinction? Does it the
same as direct and indirect effects of covariates?
</p>

<p>
We develop a framework of prediction from models with
interdependent observations.
</p>

<p>
We implement the KP1 predictors, also called exogenous by LeSage
and Pace.
</p>

<p>
We have to explain the differences between in-sample, out-of-sample
and ex-sample in a spatial context. Ex-sample is not necessary
linked to temporal, it is also interesting to counterfactual
simulations. The prediction in out-of-sample needs a certain
spatial embedding between the two spatial samples, not having
sampled neighbors does not mean no neighbors. But in a spatial
segregative case, this corresponds to a ex-sample case.
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> A taxonomy of spatial predictions</h3>
<div class="outline-text-3" id="text-1-3">
<p>
In spatial econometrics, the usual distinction between in-sample
(IS) and out-of-sample (OS) predictions has firstly to be
refined. It is not simply inside our outside the calibration sample
but it has also some relations (or not) with it.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Current function from <code>spdep</code></h2>
<div class="outline-text-2" id="text-2">
<p>
Our code is an extension of the function <code>predict.sarlm()</code> actually
the default function from the package <code>spdep</code> (Bivand).
</p>

<div class="org-src-container">

<pre class="src src-R" id="Lst:DFT"><span style="color: #4c83ff;">library</span>(spdep) ; predict.sarlm
</pre>
</div>

<p>
<a href="predict-sarlm.R">predict-sarlm.R</a>
</p>

<p>
The current function, accessible through previous link, implement
different predictor according to the absence of the presence of
newdata. For the in-sample predictions (<code>if(newdata==</code> <code>NULL)</code>), the
predictors are computed as Eq. XX using BLUP. For the out of sample
predictions (<code>if(newdata!=</code> <code>NULL)</code>), the predictors are computed as
Eq. XX using biased and inefficient predictors. It produces
inconsistencies by not implementing the same predictions if we put
the data that are used to fit the model in the <code>newdata</code> argument
(cf. XX example below). Another shortcoming of the current function
is the class of objects from SEM and SXM: they are not
vectors. Lastly, if we put <code>sacmixed</code> objects in the current
function, they are not recognized as such and produce some errors
about matrix dimension.
</p>

<p>
At the center of this distinction is the observability of the
outcome variable \(y\).
</p>

<p>
Some other particularities are present in the current function. The
OS predictor for error models is KP1 but not directly for lag
models. For that, we have to put <code>legacy==</code> <code>FALSE</code>. The signal is
computed by difference for the lag models in out of sample.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> The <code>sppred</code> extension</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> General Structure</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Here is the general structure of the functions that call
sub-functions that are defined below.
</p>

<p>
This function contents the usual verifications, with 2 more
arguments: <code>cond.set</code> for the conditional set (see XX) and <code>mean</code>
for the specification of the structural mean.
</p>

<p>
It is important that the same predictor is implemented when
newdata are NULL or not, as when spatial matrix set.
</p>

<p>
The scan for the lagged WX is by the presence of "lag." at their
name, it has to be changed.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">sppred</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(object, newdata = <span style="color: #D8FA3C;">NULL</span>, listw = <span style="color: #D8FA3C;">NULL</span>, yobs= object$y,
                   condset= <span style="color: #61CE3C;">"DEF"</span>, blup = <span style="color: #D8FA3C;">NULL</span>, loo = <span style="color: #D8FA3C;">FALSE</span>, power = <span style="color: #D8FA3C;">NULL</span>,
                   zero.policy = <span style="color: #D8FA3C;">NULL</span>, legacy = <span style="color: #D8FA3C;">TRUE</span>, order = 250,
                   tol= .Machine$double.eps^(3/5), ...) {
    <span style="color: #4c83ff;">require</span>(spdep)
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">USUAL VERIFICATIONS</span>
    <span style="color: #FBDE2D;">if</span> (is.null(zero.policy)) 
        zero.policy <span style="color: #4c83ff;">&lt;-</span> get(<span style="color: #61CE3C;">"zeroPolicy"</span>, envir = spdep:::.spdepOptions)
    stopifnot(is.logical(zero.policy))
    <span style="color: #FBDE2D;">if</span> (is.null(power)) power <span style="color: #4c83ff;">&lt;-</span> object$method != <span style="color: #61CE3C;">"eigen"</span>
    stopifnot(is.logical(legacy)) ; stopifnot(is.logical(power))
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">DETERMINING THE MODEL</span>
    <span style="color: #FBDE2D;">if</span> (object$type== <span style="color: #61CE3C;">"error"</span>){
        mod <span style="color: #4c83ff;">&lt;-</span> ifelse(object$etype== <span style="color: #61CE3C;">"error"</span>, <span style="color: #61CE3C;">"sem"</span>, <span style="color: #61CE3C;">"sxm"</span>)
    } <span style="color: #FBDE2D;">else</span> {
        mod <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(object$type, <span style="color: #61CE3C;">"lag"</span>= <span style="color: #61CE3C;">"sar"</span>, <span style="color: #61CE3C;">"mixed"</span>= <span style="color: #61CE3C;">"sdm"</span>,
                                   <span style="color: #61CE3C;">"sac"</span>= <span style="color: #61CE3C;">"sac"</span>, <span style="color: #61CE3C;">"sacmixed"</span>= <span style="color: #61CE3C;">"smc"</span>)
    }
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">DATA SHAPING</span>
    <span style="color: #FBDE2D;">if</span> (mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sem"</span>, <span style="color: #61CE3C;">"sxm"</span>)) {lab= object$lambda ; rho= 0         }
    <span style="color: #FBDE2D;">if</span> (mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sar"</span>, <span style="color: #61CE3C;">"sdm"</span>)) {lab= 0             ; rho= object$rho}
    <span style="color: #FBDE2D;">if</span> (mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sac"</span>, <span style="color: #61CE3C;">"smc"</span>)) {lab= object$lambda ; rho= object$rho}
    Wlg <span style="color: #4c83ff;">&lt;-</span> substr(names(object$coefficients), 1, 4)== <span style="color: #61CE3C;">"lag."</span>
    B <span style="color: #4c83ff;">&lt;-</span> object$coefficients[ !Wlg] ; Bl <span style="color: #4c83ff;">&lt;-</span> object$coefficients[ Wlg]
    <span style="color: #FBDE2D;">if</span> (is.null(newdata)){
        X   <span style="color: #4c83ff;">&lt;-</span> object$X[, !Wlg]
    } <span style="color: #FBDE2D;">else</span> {
        frm <span style="color: #4c83ff;">&lt;-</span> formula(object$call)
        mt  <span style="color: #4c83ff;">&lt;-</span> delete.response(terms(frm, data = newdata))
        mf  <span style="color: #4c83ff;">&lt;-</span> model.frame(mt, newdata)
        X   <span style="color: #4c83ff;">&lt;-</span> model.matrix(mt, mf)
        <span style="color: #FBDE2D;">if</span> (any(object$aliased)) X <span style="color: #4c83ff;">&lt;-</span> X[, -which(object$aliased)]
    }
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">WEIGHT MATRIX, add an error message</span>
    <span style="color: #FBDE2D;">if</span> (is.null(listw)) lsw <span style="color: #4c83ff;">&lt;-</span> eval(object$call$listw) <span style="color: #FBDE2D;">else</span> lsw <span style="color: #4c83ff;">&lt;-</span> listw
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">PREDICTORS</span>
    <span style="color: #FBDE2D;">if</span> (is.null(blup)){
        pt <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(condset, <span style="color: #61CE3C;">"X"</span>= 1, <span style="color: #61CE3C;">"XW"</span>= 2, <span style="color: #61CE3C;">"DEF"</span>= 3, <span style="color: #61CE3C;">"XWy"</span>= 4)
    } <span style="color: #FBDE2D;">else</span> {
        pt <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(blup, <span style="color: #61CE3C;">"LSP"</span>= 5, <span style="color: #61CE3C;">"KP2"</span>= 6, <span style="color: #61CE3C;">"KP3"</span>= 7, <span style="color: #61CE3C;">"KPG"</span>= 8)
    }
    prdX <span style="color: #4c83ff;">&lt;-</span> as.vector(X %*% B)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 1) prdWX   <span style="color: #4c83ff;">&lt;-</span> prdWX(prdX, X, Bl, mod, lsw)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 2 &amp;&amp; pt!= 4) prdKP1  <span style="color: #4c83ff;">&lt;-</span> prdKP1(prdWX, rho, lsw, power, order, tol)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 3){
        prdWXy <span style="color: #4c83ff;">&lt;-</span> prdWX+
            rho* lag.listw(lsw, yobs)+ lab* lag.listw(lsw, yobs- prdWX)}
    <span style="color: #FBDE2D;">if</span> (pt==5) prdLSP <span style="color: #4c83ff;">&lt;-</span> prdLSP(prdKP1, rho, lab, lsw, yobs, loo)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 5 &amp;&amp; !loo) <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"Set loo= TRUE for this blup predictor"</span>)
    <span style="color: #FBDE2D;">if</span> (pt==6){
        prdKP2 <span style="color: #4c83ff;">&lt;-</span> prdKP2(prdKP1, prdWXy,
                         rho, lab, lsw, yobs, power, order, tol)}
    <span style="color: #FBDE2D;">if</span> (pt==7){
        prdKP3 <span style="color: #4c83ff;">&lt;-</span> prdKP3(prdKP1, prdWXy,
                         rho, lab, lsw, yobs, power, order, tol)}
    <span style="color: #FBDE2D;">if</span> (pt==8) <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"not implemented"</span>)
    prd <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(pt, <span style="color: #61CE3C;">"1"</span>= prdX  , <span style="color: #61CE3C;">"2"</span>= prdWX , <span style="color: #61CE3C;">"3"</span>= prdKP1, <span style="color: #61CE3C;">"4"</span>= prdWXy,
                      <span style="color: #61CE3C;">"5"</span>= prdLSP, <span style="color: #61CE3C;">"6"</span>= prdKP2, <span style="color: #61CE3C;">"7"</span>= prdKP3, <span style="color: #61CE3C;">"8"</span>= prdKPG)
    class(prd) <span style="color: #4c83ff;">&lt;-</span> <span style="color: #61CE3C;">"sppred"</span> ; as.vector(prd)
}
</pre>
</div>

<p>
we choose to not use <code>object$tarX</code> and <code>object$tarY</code> for more
transparencies. It is clear that we lost from that in terms of
computation time. It is easy to predict by conditioning only on "X"
because it is the same form for all the spatial models (see
equation XX).
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Predictors conditioned on X, W</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> exogenous predictor</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdWX</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdX, X= X, Bl= Bl, mod= mod, lsw= lsw){
    <span style="color: #FBDE2D;">if</span> (!mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sxm"</span>, <span style="color: #61CE3C;">"sdm"</span>, <span style="color: #61CE3C;">"smc"</span>)){
        prdWX <span style="color: #4c83ff;">&lt;-</span> prdX } <span style="color: #FBDE2D;">else</span> {
            K <span style="color: #4c83ff;">&lt;-</span> ifelse(colnames(X)[ 1] == <span style="color: #61CE3C;">"(Intercept)"</span>, 2, 1)
            m <span style="color: #4c83ff;">&lt;-</span> ncol(X) ; WX <span style="color: #4c83ff;">&lt;-</span> matrix(nrow= length(prdX), ncol= m+ 1- K)
            <span style="color: #FBDE2D;">for</span> (k <span style="color: #FBDE2D;">in</span> K: m){
                WX[, k+ 1- K] <span style="color: #4c83ff;">&lt;-</span> lag.listw(lsw, X[, k])
            }
            prdWX <span style="color: #4c83ff;">&lt;-</span> prdX+ (WX %*% Bl)
        } 
    prdWX
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> endogenous predictor</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKP1</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdWX, rho= rho, lsw= lsw,
                   power= power, order= order, tol= tol){
    <span style="color: #FBDE2D;">if</span> (power){
        W <span style="color: #4c83ff;">&lt;-</span> as(as_dgRMatrix_listw(lsw), <span style="color: #61CE3C;">"CsparseMatrix"</span>)
        prdKP1 <span style="color: #4c83ff;">&lt;-</span> c(as(powerWeights(W, rho= rho, X= as.matrix(prdWX),
                                    order= order, tol= tol), <span style="color: #61CE3C;">"matrix"</span>))
    } <span style="color: #FBDE2D;">else</span> {
        prdKP1 <span style="color: #4c83ff;">&lt;-</span> c(invIrW(lsw, rho) %*% prdWX)
    }
    prdKP1
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Predictors conditioned on X, W, y</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> biased predictors</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
The predictors equivalent to KP4 and KP5, we do not let the choice
(because the omitted combination can be recovered from previous
predictors) and we can eventually add a KP6 for SAC and SMC
models. The computations are in the general.
</p>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> BLUP LSP</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
It can make sens to distinguish one shot to one leave one.
</p>


<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdLSP</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, rho= rho, lab= lab,
                   lsw= lsw, yobs= yobs, loo= loo){
    ZL <span style="color: #4c83ff;">&lt;-</span> diag(length(prdKP1))- (lab* listw2mat(lsw))
    ZR <span style="color: #4c83ff;">&lt;-</span> diag(length(prdKP1))- (rho* listw2mat(lsw))
    Z  <span style="color: #4c83ff;">&lt;-</span> ZL %*% ZR ; P22 <span style="color: #4c83ff;">&lt;-</span> t(Z) %*% Z
    <span style="color: #FBDE2D;">if</span> (loo){
        prdLSP <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdKP1))
        <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdKP1)){
            prdLSP[ i] <span style="color: #4c83ff;">&lt;-</span> prdKP1[ i]-
                (P22[i, -i] %*% (yobs[ -i]- prdKP1[ -i])/ P22[i, i])
        }
    } <span style="color: #FBDE2D;">else</span> {
        P11 <span style="color: #4c83ff;">&lt;-</span> P22
        prdLSP <span style="color: #4c83ff;">&lt;-</span> prdKP1+ ((solve(P22) %*% P11 %*% (yobs- prdKP1)))
    }
    prdLSP
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> BLUP KP2</h4>
<div class="outline-text-4" id="text-3-3-3">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKP2</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, prdWXy= prdWXy, rho= rho, lab= lab, lsw= lsw,
                   yobs= yobs, power= power, order= order, tol= tol){
    <span style="color: #FBDE2D;">if</span> (power){
        W <span style="color: #4c83ff;">&lt;-</span> as(as_dgRMatrix_listw(lsw), <span style="color: #61CE3C;">"CsparseMatrix"</span>)
        GL <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= lab, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
        GR <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= rho, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
    } <span style="color: #FBDE2D;">else</span> {
        GL <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, rho) ; GR <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, lab)
    }
    sum.u <span style="color: #4c83ff;">&lt;-</span> GL %*% t(GL) ; sum.y <span style="color: #4c83ff;">&lt;-</span> GR %*% sum.u %*% t(GR)
    prdKP2 <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdWXy))
    <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdKP2)){
        WM <span style="color: #4c83ff;">&lt;-</span> listw2mat(lsw)[i, ]
        rg <span style="color: #4c83ff;">&lt;-</span> (sum.u[i, ] %*% GR %*% WM)/ (WM %*% sum.y %*% WM)
        prdKP2[ i] <span style="color: #4c83ff;">&lt;-</span> prdWXy[ i]+ (rg %*% WM %*% (yobs- prdKP1))
    }
    prdKP2
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4"><span class="section-number-4">3.3.4</span> BLUP KP3</h4>
<div class="outline-text-4" id="text-3-3-4">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKP3</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, prdWXy= prdWXy, rho= rho, lab= lab, lsw= lsw,
                   yobs= yobs, power= power, order= order, tol= tol){
    <span style="color: #FBDE2D;">if</span> (power){
        W <span style="color: #4c83ff;">&lt;-</span> as(as_dgRMatrix_listw(lsw), <span style="color: #61CE3C;">"CsparseMatrix"</span>)
        GL <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= lab, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
        GR <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= rho, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
    } <span style="color: #FBDE2D;">else</span> {
        GL <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, lab) ; GR <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, rho)
    }
    sum.u <span style="color: #4c83ff;">&lt;-</span> GL %*% t(GL) ; sum.y <span style="color: #4c83ff;">&lt;-</span> GR %*% sum.u %*% t(GR)
    prdKP3 <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdWXy))    
    <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdKP3)){
        rg <span style="color: #4c83ff;">&lt;-</span> sum.u[i, ] %*% GR[, -i] %*% solve(sum.y[-i, -i])
        prdKP3[ i] <span style="color: #4c83ff;">&lt;-</span> prdWXy[ i]+ (rg %*% (yobs[i ]- prdKP1[-i ]))
    }
    prdKP3
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> Predictors conditioned by hand</h3>
<div class="outline-text-3" id="text-3-4">
<p>
Try with
</p>

<blockquote>
<p>
rg &lt;- sum.u[i, ] %*% GR %*% solve(sum.y)
prdKP3[ i] &lt;- prdWXy[ i]+ (rg %*% (yobs- prdKP1))
</p>
</blockquote>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> How it works</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Choosing a type of predictor</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Our new <code>R</code> function for spatial predictions &#x2013; called <code>sppred</code> for
the moment &#x2013; admits a first additional argument <code>predictor</code> that
specify the computed predictor. Knowing that predictors
corresponding to larger information sets are more complex,
flexibility is needed to let the user makes its own trade-off
between simplicity and prediction efficiency. The following table
define the available predictors.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> The available values for the new <code>predictor</code> argument</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><code>predictor</code></th>
<th scope="col" class="left">label</th>
<th scope="col" class="left">equation (see XX)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">"1"</td>
<td class="left">minimum information</td>
<td class="left">(XX)</td>
</tr>

<tr>
<td class="left">"2"</td>
<td class="left">heuristic BLUP</td>
<td class="left">(XX)</td>
</tr>

<tr>
<td class="left">"3"</td>
<td class="left">BLUP</td>
<td class="left">(XX)</td>
</tr>

<tr>
<td class="left">"4"</td>
<td class="left">heuristic data</td>
<td class="left">(XX)</td>
</tr>
</tbody>
</table>

<p>
The <code>predictor</code> 4 is currently the default for IS prediction in
<code>predict.sarlm</code> (it corresponds to the predictor KP4 for lag models
and KP5 for error models).
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Specifying</h3>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> General structure, usual checks, and IS predictions</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Here the code, for the inverse integrating directly the code from
powerWeigths?
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> The predictors 1 for OS predictions</h3>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> The <code>boston</code> example</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> Subset the dataset</h3>
<div class="outline-text-3" id="text-5-1">
<p>
and plot nb matrix
</p>

<div class="org-src-container">

<pre class="src src-R" id="Lst:SWB"><span style="color: #4c83ff;">library</span>(spdep) ; data(boston) ; <span style="color: #4c83ff;">library</span>(rgdal)
bst.sp <span style="color: #4c83ff;">&lt;-</span> readOGR(system.file(<span style="color: #61CE3C;">"etc/shapes"</span>, package= <span style="color: #61CE3C;">"spdep"</span>),
                  <span style="color: #61CE3C;">"boston_tracts"</span>, verbose= <span style="color: #D8FA3C;">FALSE</span>)
bst.nb <span style="color: #4c83ff;">&lt;-</span> poly2nb(bst.sp) ; bst.lw <span style="color: #4c83ff;">&lt;-</span> nb2listw(bst.nb)
set.seed(85) 
tst.sp <span style="color: #4c83ff;">&lt;-</span> bst.sp[cal <span style="color: #4c83ff;">&lt;-</span> unique(round(runif(250)* 500)), ]
tst.nb <span style="color: #4c83ff;">&lt;-</span> poly2nb(tst.sp) ; ins.sp <span style="color: #4c83ff;">&lt;-</span> subset(tst.sp, card(tst.nb)!= 0)
ins.nb <span style="color: #4c83ff;">&lt;-</span> poly2nb(ins.sp) ; ins.lw <span style="color: #4c83ff;">&lt;-</span> nb2listw(ins.nb)
tst.sp <span style="color: #4c83ff;">&lt;-</span> subset(bst.sp,
                 !bst.sp$poltract %<span style="color: #FBDE2D;">in</span>% levels(factor(ins.sp$poltract)))
tst.nb <span style="color: #4c83ff;">&lt;-</span> poly2nb(tst.sp) ; ots.sp <span style="color: #4c83ff;">&lt;-</span> subset(tst.sp, card(tst.nb)!= 0)
ots.nb <span style="color: #4c83ff;">&lt;-</span> poly2nb(ots.sp) ; ots.lw <span style="color: #4c83ff;">&lt;-</span> nb2listw(ots.nb)
bst <span style="color: #4c83ff;">&lt;-</span> data.frame(A= rep(row.names(bst.sp), card(bst.nb)), B= unlist(bst.nb))
ins <span style="color: #4c83ff;">&lt;-</span> data.frame(A= rep(row.names(ins.sp), card(ins.nb)), B= unlist(ins.nb))
ots <span style="color: #4c83ff;">&lt;-</span> data.frame(A= rep(row.names(ots.sp), card(ots.nb)), B= unlist(ots.nb))
ins$ins <span style="color: #4c83ff;">&lt;-</span> 1 ; ots$ots <span style="color: #4c83ff;">&lt;-</span> 1
yop <span style="color: #4c83ff;">&lt;-</span> data.frame(merge(bst, ins, by= c(<span style="color: #61CE3C;">"A"</span>, <span style="color: #61CE3C;">"B"</span>), all.x= <span style="color: #D8FA3C;">TRUE</span>),
                  <span style="color: #61CE3C;">"ots"</span>= merge(bst, ots, by= c(<span style="color: #61CE3C;">"A"</span>, <span style="color: #61CE3C;">"B"</span>), all.x= <span style="color: #D8FA3C;">TRUE</span>)[, 3])
par(mar= c(0, 0, 0, 0)) ; plot(bst.sp)
plot(ins.sp, col= <span style="color: #61CE3C;">"grey30"</span>, add= <span style="color: #D8FA3C;">TRUE</span>)
plot(ots.sp, col= <span style="color: #61CE3C;">"grey70"</span>, add= <span style="color: #D8FA3C;">TRUE</span>)
plot(bst.nb, coordinates(bst.sp), add= <span style="color: #D8FA3C;">TRUE</span>, col= <span style="color: #61CE3C;">"red"</span>)
plot(ins.nb, coordinates(ins.sp), add= <span style="color: #D8FA3C;">TRUE</span>, col= <span style="color: #61CE3C;">"blue"</span>)
plot(ots.nb, coordinates(ots.sp), add= <span style="color: #D8FA3C;">TRUE</span>, col= <span style="color: #61CE3C;">"green"</span>)
</pre>
</div>

<p>
<a href="Figures/SpWeigthBoston.pdf">Figures/SpWeigthBoston.pdf</a>
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Estimating the models</h3>
<div class="outline-text-3" id="text-5-2">
<div class="org-src-container">

<pre class="src src-R">eqn.bst <span style="color: #4c83ff;">&lt;-</span> log(CMEDV)~ CRIM    + ZN + INDUS   + CHAS    + I(NOX^2)+
                       I(RM^2) + AGE+ log(DIS)+ log(RAD)+ TAX     +
                       PTRATIO + B  + log(LSTAT)
sem <span style="color: #4c83ff;">&lt;-</span> errorsarlm(eqn.bst, data= ins.sp, ins.lw, method= <span style="color: #61CE3C;">"Matrix"</span>)
sxm <span style="color: #4c83ff;">&lt;-</span> errorsarlm(eqn.bst, data= ins.sp,
                  ins.lw, etype= <span style="color: #61CE3C;">"emixed"</span>   , method= <span style="color: #61CE3C;">"Matrix"</span>)
sar <span style="color: #4c83ff;">&lt;-</span> lagsarlm(  eqn.bst, data= ins.sp, ins.lw, method= <span style="color: #61CE3C;">"Matrix"</span>)
sdm <span style="color: #4c83ff;">&lt;-</span> lagsarlm(  eqn.bst, data= ins.sp,
                  ins.lw,  type= <span style="color: #61CE3C;">"mixed"</span>    , method= <span style="color: #61CE3C;">"Matrix"</span>)
sac <span style="color: #4c83ff;">&lt;-</span> sacsarlm(  eqn.bst, data= ins.sp, ins.lw, method= <span style="color: #61CE3C;">"Matrix"</span>)
smc <span style="color: #4c83ff;">&lt;-</span> sacsarlm(  eqn.bst, data= ins.sp,
                  ins.lw,  type= <span style="color: #61CE3C;">"sacmixed"</span> , method= <span style="color: #61CE3C;">"Matrix"</span>)
AIC(sem, sxm, sar, sdm, sac, smc)[, 2]
</pre>
</div>

<pre class="example">
[1] -150.6177 -137.7367 -143.6867 -138.6026 -148.6190 -155.1596
</pre>

<p>
The SXM is the more parsimonious in terms of AC 
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Predicting</h3>
<div class="outline-text-3" id="text-5-3">
</div><div id="outline-container-sec-5-3-1" class="outline-4">
<h4 id="sec-5-3-1"><span class="section-number-4">5.3.1</span> Inefficient predictors</h4>
<div class="outline-text-4" id="text-5-3-1">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #4c83ff;">source</span>(<span style="color: #61CE3C;">"sppred.R"</span>)
<span style="color: #ff1493;">rmse</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prd, mod) sqrt(mean(I(prd- mod$y)^2))
semKP1 <span style="color: #4c83ff;">&lt;-</span> sppred(sem) ; sxmKP1 <span style="color: #4c83ff;">&lt;-</span> sppred(sxm) ; sarKP1 <span style="color: #4c83ff;">&lt;-</span> sppred(sar)
sdmKP1 <span style="color: #4c83ff;">&lt;-</span> sppred(sdm) ; sacKP1 <span style="color: #4c83ff;">&lt;-</span> sppred(sac) ; smcKP1 <span style="color: #4c83ff;">&lt;-</span> sppred(smc)
rmse(semKP1, sem) ; rmse(sxmKP1, sxm) ; rmse(sarKP1, sar)
rmse(sdmKP1, sdm) ; rmse(sacKP1, sac) ; rmse(smcKP1, smc)

semX <span style="color: #4c83ff;">&lt;-</span> sppred(sem, condset= <span style="color: #61CE3C;">"X"</span>)
sxmX <span style="color: #4c83ff;">&lt;-</span> sppred(sxm, condset= <span style="color: #61CE3C;">"X"</span>)
sarX <span style="color: #4c83ff;">&lt;-</span> sppred(sar, condset= <span style="color: #61CE3C;">"X"</span>)
sdmX <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, condset= <span style="color: #61CE3C;">"X"</span>)
sacX <span style="color: #4c83ff;">&lt;-</span> sppred(sac, condset= <span style="color: #61CE3C;">"X"</span>)
smcX <span style="color: #4c83ff;">&lt;-</span> sppred(smc, condset= <span style="color: #61CE3C;">"X"</span>)
rmse(semX, sem) ; rmse(sxmX, sxm) ; rmse(sarX, sar)
rmse(sdmX, sdm) ; rmse(sacX, sac) ; rmse(smcX, smc)

semXW <span style="color: #4c83ff;">&lt;-</span> sppred(sem, condset= <span style="color: #61CE3C;">"XW"</span>)
sxmXW <span style="color: #4c83ff;">&lt;-</span> sppred(sxm, condset= <span style="color: #61CE3C;">"XW"</span>)
sarXW <span style="color: #4c83ff;">&lt;-</span> sppred(sar, condset= <span style="color: #61CE3C;">"XW"</span>)
sdmXW <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, condset= <span style="color: #61CE3C;">"XW"</span>)
sacXW <span style="color: #4c83ff;">&lt;-</span> sppred(sac, condset= <span style="color: #61CE3C;">"XW"</span>)
smcXW <span style="color: #4c83ff;">&lt;-</span> sppred(smc, condset= <span style="color: #61CE3C;">"XW"</span>)
rmse(semXW, sem) ; rmse(sxmXW, sxm) ; rmse(sarXW, sar)
rmse(sdmXW, sdm) ; rmse(sacXW, sac) ; rmse(smcXW, smc)

semXWy <span style="color: #4c83ff;">&lt;-</span> sppred(sem, condset= <span style="color: #61CE3C;">"XWy"</span>)
sxmXWy <span style="color: #4c83ff;">&lt;-</span> sppred(sxm, condset= <span style="color: #61CE3C;">"XWy"</span>)
sarXWy <span style="color: #4c83ff;">&lt;-</span> sppred(sar, condset= <span style="color: #61CE3C;">"XWy"</span>)
sdmXWy <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, condset= <span style="color: #61CE3C;">"XWy"</span>)
sacXWy <span style="color: #4c83ff;">&lt;-</span> sppred(sac, condset= <span style="color: #61CE3C;">"XWy"</span>)
smcXWy <span style="color: #4c83ff;">&lt;-</span> sppred(smc, condset= <span style="color: #61CE3C;">"XWy"</span>)
rmse(semXWy, sem) ; rmse(sxmXWy, sxm) ; rmse(sarXWy, sar)
rmse(sdmXWy, sdm) ; rmse(sacXWy, sac) ; rmse(smcXWy, smc)
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-5-3-2" class="outline-4">
<h4 id="sec-5-3-2"><span class="section-number-4">5.3.2</span> BLUP predictors</h4>
<div class="outline-text-4" id="text-5-3-2">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #4c83ff;">source</span>(<span style="color: #61CE3C;">"sppred.R"</span>)
<span style="color: #ff1493;">rmse</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prd, mod) sqrt(mean(I(prd- mod$y)^2))

semLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sem, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
rmse(semLSP, sem)
semKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sem, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(semKP2, sem)
semKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sem, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(semKP3, sem)

sarLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sar, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
rmse(sarLSP, sar)
sarKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sar, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(sarKP2, sar)
sarKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sar, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(sarKP3, sar)


sdmLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
rmse(sdmLSP, sem)
sdmKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(sdmKP2, sem)
sdmKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(sdmKP3, sem)



sxmLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sxm, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sarLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sar, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sdmLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sacLSP <span style="color: #4c83ff;">&lt;-</span> sppred(sac, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
smcLSP <span style="color: #4c83ff;">&lt;-</span> sppred(smc, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)

; rmse(sxmLSP, sxm) ; rmse(sarLSP, sar)
rmse(sdmLSP, sdm) ; rmse(sacLSP, sac) ; rmse(smcLSP, smc)


semKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sem, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sxmKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sxm, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sarKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sar, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sdmKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
sacKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(sac, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
smcKP2 <span style="color: #4c83ff;">&lt;-</span> sppred(smc, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>)
rmse(semKP2, sem) ; rmse(sxmKP2, sxm) ; rmse(sarKP2, sar)
rmse(sdmKP2, sdm) ; rmse(sacKP2, sac) ; rmse(smcKP2, smc)

semKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sem, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
sxmKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sxm, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
sarKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sar, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
sdmKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sdm, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
sacKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(sac, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
smcKP3 <span style="color: #4c83ff;">&lt;-</span> sppred(smc, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>, power= <span style="color: #D8FA3C;">TRUE</span>)
rmse(semKP3, sem) ; rmse(sxmKP3, sxm) ; rmse(sarKP3, sar)
rmse(sdmKP3, sdm) ; rmse(sacKP3, sac) ; rmse(smcKP3, smc)

yop <span style="color: #4c83ff;">&lt;-</span> sdmKP3- sdmXWy
yap <span style="color: #4c83ff;">&lt;-</span> sdmLSP- sdmKP1
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Changes relative to <code>predict.sarlm</code></h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Implement predictions for SARAR and Mixed SARAR models from
respectively <code>sac</code> and <code>sacmixed</code> classes.
</li>
<li>Compute BLUP and almost BLUP spatial predictors
</li>
<li>About the in-sample / out of sample structure (<code>newdata</code>)
</li>
<li>About the distinction between trend and signal
</li>
<li>The simplification of the in-sample predictions
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> About the intercept</h3>
<div class="outline-text-3" id="text-6-2">
<p>
We change the scan of the intercept, in particular in presence of
\(WX\) in the regression. If \(W\) is row standardized, we have to drop
the intercept to avoid collinearity. The initial function add the
constant at the end of the computations, we only drop the intercept
in the presence of \(WX\).
</p>


<div id="bibliography">
<h2>References</h2>

</div>


<p><a name="Anse88"></a>

<b>Anselin, L.</b> (1988). <em>Spatial Econometrics: Methods and Models</em>,
   <em>4</em>. Springer, Boston.
[&nbsp;<a href="BibPrd_bib.html#Anse88">bib</a>&nbsp;]

</p>

<p><a name="COrd73"></a>

<b>Cliff, A.&nbsp;D. and J.&nbsp;K. Ord</b> (1973). <em>Spatial Autocorrelation</em>,
  <em>5</em>. Pion, London.
[&nbsp;<a href="BibPrd_bib.html#COrd73">bib</a>&nbsp;]

</p>

<p><a name="COrd81"></a>

<b>Cliff, A.&nbsp;D. and J.&nbsp;K. Ord</b> (1981). <em>Spatial Processes, Models &amp;
  Applications</em>. Pion, London.
[&nbsp;<a href="BibPrd_bib.html#COrd81">bib</a>&nbsp;]

</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
This terminology comes from LeSage and Pace (2009) and Bivand
(2014). This model is also called spatial autoregressive model with
autoregressive disturbances, SARAR(1,1), by Kelejian and Prucha
(1998). The notations of spatial lag coefficients also depends on
authors, we adopt here those of the <b>R</b> package <code>spdep</code> (Bivand,
2014).
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
In particular, it could be of interest to predict outcome
values for units with known \(y\) for diagnostic, goodness-of-fit
purposes or computations of marginal effects of covariates.
</p></div>


</div>
</div></div>
</body>
</html>
