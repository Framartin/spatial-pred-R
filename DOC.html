<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Extending Predictions from Spatial Econometric Models on R</title>
<!-- 2014-04-20 dim. 10:50 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="Jean-Sauveur AY \\ \lt[[mailto:jsay.site@gmail.com][jsay.site@gmail.com]]jsay.site@gmail.com\gt \and Raja CHAKIR\\ \lt[[mailto:chakir@grignon.inra.fr][chakir@grignon.inra.fr]]chakir@grignon.inra.fr\gt\\ \and Julie LE GALLO\\ \lt[[mailto:jlegallo@univ-fcomte.fr][jlegallo@univ-fcomte.fr]]jlegallo@univ-fcomte.fr\gt" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="http://thomasf.github.io/solarized-css/solarized-light.min.css" />

<script type="text/javascript" src="http://thomasf.github.io/solarized-css/org-info.min.js">
/**
 *
 * @source: http://thomasf.github.io/solarized-css/org-info.min.js
 *
 * @licstart  The following is the entire license notice for the
 *  JavaScript code in http://thomasf.github.io/solarized-css/org-info.min.js.
 *
 * Copyright (C) 2012-2013 Free Software Foundation, Inc.
 *
 *
 * The JavaScript code in this tag is free software: you can
 * redistribute it and/or modify it under the terms of the GNU
 * General Public License (GNU GPL) as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option)
 * any later version.  The code is distributed WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
 *
 * As additional permission under GNU GPL version 3 section 7, you
 * may distribute non-source (e.g., minimized or compacted) forms of
 * that code without the copy of the GNU GPL normally required by
 * section 4, provided you include this license notice and a URL
 * through which recipients can access the Corresponding Source.
 *
 * @licend  The above is the entire license notice
 * for the JavaScript code in http://thomasf.github.io/solarized-css/org-info.min.js.
 *
 */
</script>

<script type="text/javascript">

/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/

<!--/*--><![CDATA[/*><!--*/
org_html_manager.set("TOC_DEPTH", "5");
org_html_manager.set("LINK_HOME", "");
org_html_manager.set("LINK_UP", "");
org_html_manager.set("LOCAL_TOC", "0");
org_html_manager.set("VIEW_BUTTONS", "0");
org_html_manager.set("MOUSE_HINT", "underline");
org_html_manager.set("FIXED_TOC", "0");
org_html_manager.set("TOC", "0");
org_html_manager.set("VIEW", "showall");
org_html_manager.setup();  // activate after the parameters are set
/*]]>*///-->
</script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Extending Predictions from Spatial Econometric Models on R</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Theoretical Framework</a>
<ul>
<li><a href="#sec-1-1">1.1. Spatial econometric models</a></li>
<li><a href="#sec-1-2">1.2. Implementing predictions</a></li>
<li><a href="#sec-1-3">1.3. A taxonomy of spatial sample schemes</a></li>
</ul>
</li>
<li><a href="#sec-2">2. Current function from <code>spdep</code></a></li>
<li><a href="#sec-3">3. The new <code>sppred</code> extension</a>
<ul>
<li><a href="#sec-3-1">3.1. General Structure</a></li>
<li><a href="#sec-3-2">3.2. Predictors conditioned on X, W</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1. exogenous predictor</a></li>
<li><a href="#sec-3-2-2">3.2.2. endogenous predictor</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3. Predictors conditioned on X, W, y</a>
<ul>
<li><a href="#sec-3-3-1">3.3.1. biased predictors</a></li>
<li><a href="#sec-3-3-2">3.3.2. BLUP LSP</a></li>
<li><a href="#sec-3-3-3">3.3.3. BLUP KP2</a></li>
<li><a href="#sec-3-3-4">3.3.4. BLUP KP3</a></li>
<li><a href="#sec-3-3-5">3.3.5. BLUP Generalized</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-4">4. How it works</a>
<ul>
<li><a href="#sec-4-1">4.1. Choosing a type of predictor</a></li>
<li><a href="#sec-4-2">4.2. Specifying</a></li>
<li><a href="#sec-4-3">4.3. General structure, usual checks, and IS predictions</a></li>
<li><a href="#sec-4-4">4.4. The predictors 1 for OS predictions</a></li>
</ul>
</li>
<li><a href="#sec-5">5. The <code>boston</code> example</a>
<ul>
<li><a href="#sec-5-1">5.1. The spatial samples</a></li>
<li><a href="#sec-5-2">5.2. Neighborhood relationships</a></li>
<li><a href="#sec-5-3">5.3. Estimating the models</a></li>
<li><a href="#sec-5-4">5.4. Predicting for in-sample</a></li>
<li><a href="#sec-5-5">5.5. Recovering impact measures</a></li>
<li><a href="#sec-5-6">5.6. Recovering trend and signal terms</a></li>
</ul>
</li>
<li><a href="#sec-6">6. Summary</a>
<ul>
<li><a href="#sec-6-1">6.1. Changes relative to <code>predict.sarlm</code></a></li>
<li><a href="#sec-6-2">6.2. About the intercept</a></li>
</ul>
</li>
<li><a href="#sec-7">7. Appendix</a>
<ul>
<li><a href="#sec-7-1">7.1. Subset function for <code>nb</code> objects</a></li>
<li><a href="#sec-7-2">7.2. Subset function for <code>listw</code> objects</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="abstract">
<p>
This document presents an integrative framework to make predictions
from spatial autoregressive models ([<a href="#COrd73">COrd73</a>,<a href="# COrd81"> COrd81</a>,<a href="# Anse88"> Anse88</a>]). It
also contains the corresponding <a href="http:www.r-project.org"><b>R</b> code</a> to implement the predictors
presented. The code is tangled into the <a href="./sppred.R"><code>sppred</code></a> function that
implements in particular the predictors from [<a href="#LPac04">LPac04</a>,<a href="# PLes08"> PLes08</a>] and
[<a href="#KPru07">KPru07</a>] for a large number of specifications of spatial
autocorrelation from the <a href="http:cran.r-project.org/web/packages/spdep/index.html"><code>spdep</code> package</a> ([<a href="#Biva14">Biva14</a>]). To use this
code, save the file <a href="./sppred.R"><code>sppred</code></a> in your working directory then submit
<code>source("sppred.R")</code> to <b>R</b>. Some examples on the <code>boston</code> data are
also available at section XX. The status of this work is actually
under construction, comments are welcome.<br  />
</p>

<p>
<b><code>STILL TODO</code></b> 
</p>
<ul class="org-ul">
<li>Code the variances and confidence intervals of predictors
</li>
<li>Code the weight matrix for ex-sample predictions
</li>
<li>Code the predictors for <code>sphet</code> and <code>splm</code> objects
</li>
<li>Allow models with transformed outcome variable
</li>
</ul>

</div>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Theoretical Framework</a></li>
<li><a href="#sec-2">2. Current function from <code>spdep</code></a></li>
<li><a href="#sec-3">3. The new <code>sppred</code> extension</a></li>
<li><a href="#sec-4">4. How it works</a></li>
<li><a href="#sec-5">5. The <code>boston</code> example</a></li>
<li><a href="#sec-6">6. Summary</a></li>
<li><a href="#sec-7">7. Appendix</a></li>
</ul>
</div>
</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> Theoretical Framework</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> Spatial econometric models</h3>
<div class="outline-text-3" id="text-1-1">
<p>
The particularity of spatial econometric models is the <i>ex ante</i>
specification of interdependence between statistical units,
typically from their spatial proximity.  Consequently, resulting
predictions not only depend on the variables of the target units
(i.e., the units for which we want to predict the outcome) but
potentially involve the entire set of both explanatory as well as
dependent variable sample data observations.  This implies that the
sample pattern of the outcomes or the residuals contains additional
information which may be used to modify the regression function so
as to reduce the prediction variance [<a href="#Gold62">Gold62</a>].
</p>

<p>
The literature about predicting from spatial econometric models is
not actually unified, due to different modeling frameworks and
notations: see [<a href="#LPac04">LPac04</a>,<a href="# PLes08"> PLes08</a>] and [<a href="#KPru07">KPru07</a>].  A first
contribution of this document is to unify the different predictors
proposed in the literature into an integrative spatial econometric
framework.  A second contribution is to present the <b>R</b> function
<code>sppred</code> that implements all the spatial predictors and presents
some empirical evidence on their relative performance on a
well-known dataset (<code>boston</code>, [<a href="#Biva14">Biva14</a>]).
</p>

<p>
We present analytically the available predictors from spatial
econometric models estimated on a sample of \(N\) spatial units. We
begin with the more general spatial autoregressive mixed
conditional (SMC) specification of the Cliff-Ord (1973, 1981) class
of homoscedastic models with exogenous covariates,<sup><a id="fnr.1" name="fnr.1" class="footref" href="#fn.1">1</a></sup>
</p>

\begin{align}
y & = \alpha+ \rho Wy+X\beta+ WX\theta+ u\nonumber\\
u & = \lambda W u+ \varepsilon \;\;\mbox{ with }\;\; \varepsilon\sim \mathbf{N}(0, \sigma^2I_N)\nonumber
\end{align}

<p>
The term \(y\) is a \(N\times 1\) vector of the continuous outcome of
interest, \(X\) is a \(N\times K\) matrix of the \(K\) non-constant
covariates, and \(W\) is a \(N\times N\) full-rank spatial weight
matrix (see Anselin 1988). We limit ourselves to a same weight
matrix in the outcome and error equations, but formally nothing
requires this restriction. The unknown parameters (or vectors of
parameters) \(\alpha\), \(\rho\), \(\beta\), \(\theta\), \(\lambda\) and
\(\sigma\) grouped in \(\Theta\) have to be estimated, as the vector
\(\varepsilon\) of innovations. Classically, we assume that
\(\mbox{diag}(W)= 0\) and \(|\,\rho\,|\), \(|\,\lambda\,|< 1\). The
spatial weight matrix \(W\) does not need to be symmetric.
</p>

<p>
This form is sufficiently general that the spatial autoregressive
conditional (SAC) model can be recovered with \(\theta= 0\), the
spatial Durbin model (SDM) model with \(\lambda=0\), the spatial
autoregressive (SAR) model with \(\theta=\lambda=0\), the spatial X
model (SXM, also called Spatial Durban Error Model by LeSage and
Pace, 2009) with \(\rho=0\) and the spatial error model (SEM) can be
recovered with \(\rho=\theta= 0\). All these models can be estimated
by maximum likelihood through the functions <code>errorsarlm</code>,
<code>lagsarlm</code>, and <code>sacsarlm</code> of the <b>R</b> package <code>spdep</code> (Bivand,
2014).
</p>

<p>
For future reference, note that the general SMC model can be
reduced in \(y= (I-\rho W)^{-1}X\beta +(I-\rho W)^{-1}(I-\lambda
   W)^{-1}\varepsilon\), with a distribution that involves all of the
model parameters:
</p>

\begin{equation}
y\mid X, W, \Theta \sim \mathbf{N}(\mu, \sigma_{\varepsilon}^2\Sigma),
\end{equation}

<p>
with \(\mu=(I-\rho W)^{-1}X\beta\), and \(\Sigma= \big[(I-\rho
   W)(I-\lambda W)(I-\lambda W^\top)(I-\rho W^\top)\big]^{-1}\).  With
this writing, we can distinguish the non-stochastic and the
stochastic components of the observations, which are of central
interest in unifying the different predictors.  According to the
literature, we consider hereafter that the set of parameters
\(\Theta\) is known with certainty.  This has the advantage of
simplifying notations by neglecting a source of uncertainty that
depends on the sample size.  Moreover, all the parameters are
estimated simultaneously and it makes no sens to consider \(\Theta\)
as partially known.  Hence, the predictors presented are all
conditioned by \(\Theta\), which is dropped from conditioning sets
for the sake of clarity. So its not the true BLUP but an
approximation, in this framework parameters are exogenous.
</p>

<p>
Finally, note that geo-statistical models (typically from the
kriging methods, [<a href="#CCas93">CCas93</a>]) are aware about the need for using
BLUP predictors.  Relatively to spatial econometric approaches,
they involve specifying spatial dependence through the error
process (like in spatial error models, see below) as opposed to the
spatial lag of the outcome vector.  Predicting from these error
models take a simpler form than autoregressive models and can be
easily recovered from the theoretical framework presented here. The
reverse is not true.<sup><a id="fnr.2" name="fnr.2" class="footref" href="#fn.2">2</a></sup>
</p>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> Implementing predictions</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Basically, we consider \(M\) target spatial units for which we want
to predict the values of the outcome \(y\).  These units may or may
not be included in the dataset used for the estimation of the
parameters (that we call focal units).  At this moment, it makes no
differences and we distinguish them only in the research interest
of obtaining predictions of \(y\).<sup><a id="fnr.3" name="fnr.3" class="footref" href="#fn.3">3</a></sup> We discuss this point in
more details at the next subsection XX.
</p>

<p>
The available information set is crucial here, as each predictor is
formulated as a conditional expectation relative to it. 
</p>

<p>
. in terms of conditional expectation put the focus of
   the available information used to construct the predictors which is
   important for the transparency of the code. 
</p>

\begin{equation}
\tag{PRD.X}\mathbf{E}(y\mid X)= X \widehat{\beta}\nonumber
\end{equation}

\begin{equation}
\tag{PRD.WX}\mathbf{E}(y\mid X, W)= X\widehat{\beta}+ WX\widehat{\theta}
\end{equation}

\begin{equation}
\tag{PRD.KP1}\mathbf{E}(y\mid X, W)= (I_n-\rho W)^{-1} (X\widehat{\beta}+ WX\widehat{\theta})
\end{equation}

<p>
This correspond to KP1 but also the exogenous predictor of LSP. It
is the default predictor of the function <code>sppred</code>.
</p>

\begin{equation}
\tag{PRD4}\mathbf{E}(y\mid X, W, Wy)= \rho Wy+ X\widehat{\beta}+ WX\widehat{\theta}+ \lambda (Wy- X\beta- WX\theta)
\end{equation}

<p>
It is a bit strange but \(y\) cannot be recovered from \(W\) and
\(Wy\). KP analyses this predictor separately in KP4 and KP5 but such
a distinction is not necessary.  Since \(\mbox{diag}(W)=0\), \(W y\)
does not use individually the \(y_i\) to predict itself but needs
them all to predict the entire vector.
</p>

<p>
The bias of actual predictors come from the correlation between the
spatially lagged dependent variable and the error term. It is why
the use of best linear unbiased predictor (Golberger) is of
particular importance.
</p>

\begin{equation}
\tag{PRD5}\mathbf{E}(y\mid X, W, y_{IS})= (I_n-\rho W)^{-1} X\widehat{\beta}+ WX\widehat{\theta}
                                        + \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))
\end{equation}

<p>
The covariance can be simplified with precision matrix (Harville)
which do not necessitate the inversion of matrix:
\(\Omega_{21}\Omega_{11}^{-1}= \Psi_{21}\Psi_{11}^{-1}\). LSP also
present a leave-one-out (loo) specification of this predictor, that
is based on the same conditioning set, except that we consider the
predictions individually of each OS units indexed \(i\).
</p>

\begin{equation}
\tag{prdLSP}\mathbf{E}(y_i\mid X, W, y_{IS})= (I_n-\rho W)^{-1}X\widehat{\beta}+ WX\widehat{\theta}
                                            + \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))\label{prdLSP}
\end{equation}

<p>
This simplification comes from&#x2026;
</p>

<p>
Note that this predictor is not consistent in terms of expectation
conditioned by a unique information set. In effect, the
non-stochastic part is conditioned without the knowledge of the
outcome variable, which is nevertheless necessary to compute the
BLUP correction of the stochastic part. This misleading appears
because of the writing of the reduced form before taking the
conditional expectation.
</p>

\begin{equation}
\tag{prdKP2}\mathbf{E}(y_i\mid X, W, y_{IS})= \rho Wy+ X\widehat{\beta}+ WX\widehat{\theta} 
                                            +  \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))
\end{equation}

<p>
yopla
</p>

\begin{equation}
\tag{prdKP2}\mathbf{E}(y_i\mid X, W, y_{IS})= \rho Wy+ X\widehat{\beta}+ WX\widehat{\theta}
                                        + \Omega_{21}\Omega_{11}^{-1}(y_{IS}-\mathbf{E}(y_{IS}\mid X, W))
\end{equation}

<p>
If we put aside the differences in the conditional mean of the
exogenous part, this predictor <code>predKP2</code> is identical to <i>prdLSP</i>.
</p>

<p>
Can we still maintain the signal trend distinction? Does it the
same as direct and indirect effects of covariates?
</p>

<p>
We develop a framework of prediction from models with
interdependent observations.
</p>

<p>
We implement the KP1 predictors, also called exogenous by LeSage
and Pace.
</p>

<p>
Custom predictors, see for example [<a href="#TALG13">TALG13</a>]</p>

<p>
We have to explain the differences between in-sample, out-of-sample
and ex-sample in a spatial context. Ex-sample is not necessary
linked to temporal, it is also interesting to counterfactual
simulations. The prediction in out-of-sample needs a certain
spatial embedding between the two spatial samples, not having
sampled neighbors does not mean no neighbors. But in a spatial
segregative case, this corresponds to a ex-sample case.
</p>

<p>
In the applied literature, one can found KP2 in Dubin (models?), KP4
in [<a href="#BCHo07">BCHo07</a>] (models?), LSP in Kato (models?)
</p>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> A taxonomy of spatial sample schemes</h3>
<div class="outline-text-3" id="text-1-3">
<p>
ex-post predictions, for the temporal dimension. ex-ante we have to
also estimate the independent variables
</p>

<p>
In spatial econometrics, the usual distinction between in-sample
(IS) and out-of-sample (OS) predictions has firstly to be
refined. It is not simply inside our outside the calibration sample
but it has also some relations (or not) with it.
</p>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> Current function from <code>spdep</code></h2>
<div class="outline-text-2" id="text-2">
<p>
Our code is an extension of the function <code>predict.sarlm()</code> actually
the default function from the package <code>spdep</code> (Bivand).
</p>

<div class="org-src-container">

<pre class="src src-R" id="Lst:DFT"><span style="color: #4c83ff;">library</span>(spdep) ; predict.sarlm
</pre>
</div>

<p>
<a href="predict-sarlm.R">predict-sarlm.R</a>
</p>

<p>
The current function, accessible through previous link, implement
different predictor according to the absence of the presence of
newdata. For the in-sample predictions (<code>if(newdata==</code> <code>NULL)</code>), the
predictors are computed as Eq. XX using BLUP. For the out of sample
predictions (<code>if(newdata!=</code> <code>NULL)</code>), the predictors are computed as
Eq. XX using biased and inefficient predictors. It produces
inconsistencies by not implementing the same predictions if we put
the data that are used to fit the model in the <code>newdata</code> argument
(cf. XX example below). Another shortcoming of the current function
is the class of objects from SEM and SXM: they are not
vectors. Lastly, if we put <code>sacmixed</code> objects in the current
function, they are not recognized as such and produce some errors
about matrix dimension.
</p>

<p>
At the center of this distinction is the observability of the
outcome variable \(y\).
</p>

<p>
Some other particularities are present in the current function. The
OS predictor for error models is KP1 but not directly for lag
models. For that, we have to put <code>legacy==</code> <code>FALSE</code>. The signal is
computed by difference for the lag models in out of sample.
</p>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> The new <code>sppred</code> extension</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> General Structure</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Here is the general structure of the functions that call
sub-functions that are defined below.
</p>

<p>
This function contents the usual verifications, with 2 more
arguments: <code>cond.set</code> for the conditional set (see XX) and <code>mean</code>
for the specification of the structural mean.
</p>

<p>
It is important that the same predictor is implemented when
newdata are NULL or not, as when spatial matrix set.
</p>

<p>
The scan for the lagged WX is by the presence of "lag." at their
name, it has to be changed.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">sppred</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(object, newdata = <span style="color: #D8FA3C;">NULL</span>, listw = <span style="color: #D8FA3C;">NULL</span>, yobs= object$y,
                   condset= <span style="color: #61CE3C;">"DEF"</span>, blup = <span style="color: #D8FA3C;">NULL</span>, loo = <span style="color: #D8FA3C;">FALSE</span>, rg = <span style="color: #D8FA3C;">NULL</span>,
                   power = <span style="color: #D8FA3C;">NULL</span>, zero.policy = <span style="color: #D8FA3C;">NULL</span>, legacy = <span style="color: #D8FA3C;">TRUE</span>, order = 250,
                   tol= .Machine$double.eps^(3/5), ..., tst= 1) {
    <span style="color: #4c83ff;">require</span>(spdep)
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">USUAL VERIFICATIONS</span>
    <span style="color: #FBDE2D;">if</span> (is.null(zero.policy)) 
        zero.policy <span style="color: #4c83ff;">&lt;-</span> get(<span style="color: #61CE3C;">"zeroPolicy"</span>, envir = spdep:::.spdepOptions)
    stopifnot(is.logical(zero.policy))
    <span style="color: #FBDE2D;">if</span> (is.null(power)) power <span style="color: #4c83ff;">&lt;-</span> object$method != <span style="color: #61CE3C;">"eigen"</span>
    stopifnot(is.logical(legacy)) ; stopifnot(is.logical(power))
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">DETERMINING THE MODEL</span>
    <span style="color: #FBDE2D;">if</span> (object$type== <span style="color: #61CE3C;">"error"</span>){
        mod <span style="color: #4c83ff;">&lt;-</span> ifelse(object$etype== <span style="color: #61CE3C;">"error"</span>, <span style="color: #61CE3C;">"sem"</span>, <span style="color: #61CE3C;">"sxm"</span>)
    } <span style="color: #FBDE2D;">else</span> {
        mod <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(object$type, <span style="color: #61CE3C;">"lag"</span>= <span style="color: #61CE3C;">"sar"</span>, <span style="color: #61CE3C;">"mixed"</span>= <span style="color: #61CE3C;">"sdm"</span>,
                                   <span style="color: #61CE3C;">"sac"</span>= <span style="color: #61CE3C;">"sac"</span>, <span style="color: #61CE3C;">"sacmixed"</span>= <span style="color: #61CE3C;">"smc"</span>)}
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">DATA SHAPING</span>
    <span style="color: #FBDE2D;">if</span> (mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sem"</span>, <span style="color: #61CE3C;">"sxm"</span>)) {lab= object$lambda ; rho= 0         }
    <span style="color: #FBDE2D;">if</span> (mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sar"</span>, <span style="color: #61CE3C;">"sdm"</span>)) {lab= 0             ; rho= object$rho}
    <span style="color: #FBDE2D;">if</span> (mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sac"</span>, <span style="color: #61CE3C;">"smc"</span>)) {lab= object$lambda ; rho= object$rho}
    Wlg <span style="color: #4c83ff;">&lt;-</span> substr(names(object$coefficients), 1, 4)== <span style="color: #61CE3C;">"lag."</span>
    B <span style="color: #4c83ff;">&lt;-</span> object$coefficients[ !Wlg] ; Bl <span style="color: #4c83ff;">&lt;-</span> object$coefficients[ Wlg]
    <span style="color: #FBDE2D;">if</span> (is.null(newdata)){
        X   <span style="color: #4c83ff;">&lt;-</span> object$X[, !Wlg]
    } <span style="color: #FBDE2D;">else</span> {
        frm <span style="color: #4c83ff;">&lt;-</span> formula(object$call)
        mt  <span style="color: #4c83ff;">&lt;-</span> delete.response(terms(frm, data = newdata))
        mf  <span style="color: #4c83ff;">&lt;-</span> model.frame(mt, newdata)
        X   <span style="color: #4c83ff;">&lt;-</span> model.matrix(mt, mf)
        <span style="color: #FBDE2D;">if</span> (any(object$aliased)) X <span style="color: #4c83ff;">&lt;-</span> X[, -which(object$aliased)]
    }
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">WEIGHT MATRIX</span>
    <span style="color: #FBDE2D;">if</span> (is.null(listw)) lsw <span style="color: #4c83ff;">&lt;-</span> eval(object$call$listw) <span style="color: #FBDE2D;">else</span> lsw <span style="color: #4c83ff;">&lt;-</span> listw
    <span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">PREDICTORS</span>
    <span style="color: #FBDE2D;">if</span> (is.null(blup)){
        pt <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(condset, <span style="color: #61CE3C;">"X"</span>= 1, <span style="color: #61CE3C;">"XW"</span>= 2, <span style="color: #61CE3C;">"DEF"</span>= 3, <span style="color: #61CE3C;">"XWy"</span>= 4)
    } <span style="color: #FBDE2D;">else</span> {
        pt <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(blup, <span style="color: #61CE3C;">"LSP"</span>= 5, <span style="color: #61CE3C;">"KPG"</span>= 6, <span style="color: #61CE3C;">"KP2"</span>= 7, <span style="color: #61CE3C;">"KP3"</span>= 8)
    }
    prdX <span style="color: #4c83ff;">&lt;-</span> as.vector(X %*% B)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 1) prdWX   <span style="color: #4c83ff;">&lt;-</span> prdWX(prdX, X, Bl, mod, lsw)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 2 &amp;&amp; pt!= 4) prdKP1  <span style="color: #4c83ff;">&lt;-</span> prdKP1(prdWX, rho, lsw, power, order, tol)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 3 &amp;&amp; tst== 1){
        prdWXy <span style="color: #4c83ff;">&lt;-</span> prdWX+
            rho* lag.listw(lsw, yobs)+ lab* lag.listw(lsw, yobs- prdWX)}
    <span style="color: #FBDE2D;">if</span> (pt&gt; 3 &amp;&amp; tst== 2){
        prdWXy <span style="color: #4c83ff;">&lt;-</span> prdWX+ rho* lag.listw(lsw, yobs)}
    <span style="color: #FBDE2D;">if</span> (pt==5) prdLSP <span style="color: #4c83ff;">&lt;-</span> prdLSP(prdKP1, rho, lab, lsw, yobs, loo)
    <span style="color: #FBDE2D;">if</span> (pt==6) prdKPG <span style="color: #4c83ff;">&lt;-</span> prdKPG(prdKP1, prdWXy, rg, yobs)
    <span style="color: #FBDE2D;">if</span> (pt&gt; 6 &amp;&amp; !loo) <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"Set loo= TRUE for this blup predictor"</span>)
    <span style="color: #FBDE2D;">if</span> (pt==7){
        prdKP2 <span style="color: #4c83ff;">&lt;-</span> prdKP2(prdKP1, prdWXy,
                         rho, lab, lsw, yobs, power, order, tol)}
    <span style="color: #FBDE2D;">if</span> (pt==8){
        prdKP3 <span style="color: #4c83ff;">&lt;-</span> prdKP3(prdKP1, prdWXy,
                         rho, lab, lsw, yobs, power, order, tol)}
    prd <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">switch</span>(pt, <span style="color: #61CE3C;">"1"</span>= prdX  , <span style="color: #61CE3C;">"2"</span>= prdWX , <span style="color: #61CE3C;">"3"</span>= prdKP1, <span style="color: #61CE3C;">"4"</span>= prdWXy,
                      <span style="color: #61CE3C;">"5"</span>= prdLSP, <span style="color: #61CE3C;">"6"</span>= prdKPG, <span style="color: #61CE3C;">"7"</span>= prdKP2, <span style="color: #61CE3C;">"8"</span>= prdKP3)
    class(prd) <span style="color: #4c83ff;">&lt;-</span> <span style="color: #61CE3C;">"sppred"</span> ; as.vector(prd)
}
</pre>
</div>

<p>
we choose to not use <code>object$tarX</code> and <code>object$tarY</code> for more
transparencies. It is clear that we lost from that in terms of
computation time. It is easy to predict by conditioning only on "X"
because it is the same form for all the spatial models (see
equation XX).
</p>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> Predictors conditioned on X, W</h3>
<div class="outline-text-3" id="text-3-2">
</div><div id="outline-container-sec-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> exogenous predictor</h4>
<div class="outline-text-4" id="text-3-2-1">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdWX</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdX, X= X, Bl= Bl, mod= mod, lsw= lsw){
    <span style="color: #FBDE2D;">if</span> (!mod %<span style="color: #FBDE2D;">in</span>% c(<span style="color: #61CE3C;">"sxm"</span>, <span style="color: #61CE3C;">"sdm"</span>, <span style="color: #61CE3C;">"smc"</span>)){
        prdWX <span style="color: #4c83ff;">&lt;-</span> prdX } <span style="color: #FBDE2D;">else</span> {
            K <span style="color: #4c83ff;">&lt;-</span> ifelse(colnames(X)[ 1] == <span style="color: #61CE3C;">"(Intercept)"</span>, 2, 1)
            m <span style="color: #4c83ff;">&lt;-</span> ncol(X) ; WX <span style="color: #4c83ff;">&lt;-</span> matrix(nrow= length(prdX), ncol= m+ 1- K)
            <span style="color: #FBDE2D;">for</span> (k <span style="color: #FBDE2D;">in</span> K: m){
                WX[, k+ 1- K] <span style="color: #4c83ff;">&lt;-</span> lag.listw(lsw, X[, k])
            }
            prdWX <span style="color: #4c83ff;">&lt;-</span> prdX+ (WX %*% Bl)
        } 
    prdWX
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> endogenous predictor</h4>
<div class="outline-text-4" id="text-3-2-2">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKP1</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdWX, rho= rho, lsw= lsw,
                   power= power, order= order, tol= tol){
    <span style="color: #FBDE2D;">if</span> (power){
        W <span style="color: #4c83ff;">&lt;-</span> as(as_dgRMatrix_listw(lsw), <span style="color: #61CE3C;">"CsparseMatrix"</span>)
        prdKP1 <span style="color: #4c83ff;">&lt;-</span> c(as(powerWeights(W, rho= rho, X= as.matrix(prdWX),
                                    order= order, tol= tol), <span style="color: #61CE3C;">"matrix"</span>))
    } <span style="color: #FBDE2D;">else</span> {
        prdKP1 <span style="color: #4c83ff;">&lt;-</span> c(invIrW(lsw, rho) %*% prdWX)
    }
    prdKP1
}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> Predictors conditioned on X, W, y</h3>
<div class="outline-text-3" id="text-3-3">
</div><div id="outline-container-sec-3-3-1" class="outline-4">
<h4 id="sec-3-3-1"><span class="section-number-4">3.3.1</span> biased predictors</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
The predictors equivalent to KP4 and KP5, we do not let the choice
(because the omitted combination can be recovered from previous
predictors) and we can eventually add a KP6 for SAC and SMC
models. The computations are in the general.
</p>
</div>
</div>
<div id="outline-container-sec-3-3-2" class="outline-4">
<h4 id="sec-3-3-2"><span class="section-number-4">3.3.2</span> BLUP LSP</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
It can make sens to distinguish one shot to one leave one.
</p>


<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdLSP</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, rho= rho, lab= lab,
                   lsw= lsw, yobs= yobs, loo= loo){
    ZL <span style="color: #4c83ff;">&lt;-</span> diag(length(prdKP1))- (lab* listw2mat(lsw))
    ZR <span style="color: #4c83ff;">&lt;-</span> diag(length(prdKP1))- (rho* listw2mat(lsw))
    Z  <span style="color: #4c83ff;">&lt;-</span> ZL %*% ZR ; P22 <span style="color: #4c83ff;">&lt;-</span> t(Z) %*% Z
    <span style="color: #FBDE2D;">if</span> (loo){
        prdLSP <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdKP1))
        <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdKP1)){
            prdLSP[ i] <span style="color: #4c83ff;">&lt;-</span> prdKP1[ i]-
                (P22[i, -i] %*% (yobs[ -i]- prdKP1[ -i])/ P22[i, i])
        }
    } <span style="color: #FBDE2D;">else</span> {
        P11 <span style="color: #4c83ff;">&lt;-</span> P22
        prdLSP <span style="color: #4c83ff;">&lt;-</span> prdKP1+ ((solve(P22) %*% P11 %*% (yobs- prdKP1)))
    }
    prdLSP
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-3" class="outline-4">
<h4 id="sec-3-3-3"><span class="section-number-4">3.3.3</span> BLUP KP2</h4>
<div class="outline-text-4" id="text-3-3-3">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKP2</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, prdWXy= prdWXy, rho= rho, lab= lab, lsw= lsw,
                   yobs= yobs, power= power, order= order, tol= tol){
    <span style="color: #FBDE2D;">if</span> (power){
        W <span style="color: #4c83ff;">&lt;-</span> as(as_dgRMatrix_listw(lsw), <span style="color: #61CE3C;">"CsparseMatrix"</span>)
        GL <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= lab, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
        GR <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= rho, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
    } <span style="color: #FBDE2D;">else</span> {
        GL <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, rho) ; GR <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, lab)
    }
    sum.u <span style="color: #4c83ff;">&lt;-</span> GL %*% t(GL) ; sum.y <span style="color: #4c83ff;">&lt;-</span> GR %*% sum.u %*% t(GR)
    prdKP2 <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdWXy))
    <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdKP2)){
        WM <span style="color: #4c83ff;">&lt;-</span> listw2mat(lsw)[i, ]
        rg <span style="color: #4c83ff;">&lt;-</span> (sum.u[i, ] %*% GR %*% WM)/ (WM %*% sum.y %*% WM)
        prdKP2[ i] <span style="color: #4c83ff;">&lt;-</span> prdWXy[ i]+ (rg %*% WM %*% (yobs- prdKP1))
    }
    prdKP2
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-4" class="outline-4">
<h4 id="sec-3-3-4"><span class="section-number-4">3.3.4</span> BLUP KP3</h4>
<div class="outline-text-4" id="text-3-3-4">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKP3</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, prdWXy= prdWXy, rho= rho, lab= lab, lsw= lsw,
                   yobs= yobs, power= power, order= order, tol= tol){
    <span style="color: #FBDE2D;">if</span> (power){
        W <span style="color: #4c83ff;">&lt;-</span> as(as_dgRMatrix_listw(lsw), <span style="color: #61CE3C;">"CsparseMatrix"</span>)
        GL <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= lab, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
        GR <span style="color: #4c83ff;">&lt;-</span> as(powerWeights(W, rho= rho, order= order, tol= tol,
                              X= diag(length(prdWXy))), <span style="color: #61CE3C;">"matrix"</span>)
    } <span style="color: #FBDE2D;">else</span> {
        GL <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, lab) ; GR <span style="color: #4c83ff;">&lt;-</span> invIrW(lsw, rho)
    }
    sum.u <span style="color: #4c83ff;">&lt;-</span> GL %*% t(GL) ; sum.y <span style="color: #4c83ff;">&lt;-</span> GR %*% sum.u %*% t(GR)
    prdKP3 <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdWXy))    
    <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdKP3)){
        rg <span style="color: #4c83ff;">&lt;-</span> sum.u[i, ] %*% GR[, -i] %*% solve(sum.y[-i, -i])
        prdKP3[ i] <span style="color: #4c83ff;">&lt;-</span> prdWXy[ i]+ (rg %*% (yobs[i ]- prdKP1[-i ]))
    }
    prdKP3
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-3-3-5" class="outline-4">
<h4 id="sec-3-3-5"><span class="section-number-4">3.3.5</span> BLUP Generalized</h4>
<div class="outline-text-4" id="text-3-3-5">
<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">prdKPG</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prdKP1, prdWXy= prdWXy, yobs= yobs, rg= rg, loo= loo){
    <span style="color: #FBDE2D;">if</span>(dim(rg)[ 1]!= length(yobs) || dim(rg)[ 2]!= length(yobs))
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"BLUP correction is not of the good dimension"</span>)
    <span style="color: #FBDE2D;">if</span> (loo){
        prdKPG <span style="color: #4c83ff;">&lt;-</span> matrix(<span style="color: #D8FA3C;">NA</span>, ncol= 1, nrow= length(prdWXy))
        <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1: length(prdWXy)){
            prdKPG[ i] <span style="color: #4c83ff;">&lt;-</span> prdWXy[ i]-
                (rg[i, -i] %*% (yobs[ -i]- prdKP1[ -i])/ rg[i, i])
        }
    } <span style="color: #FBDE2D;">else</span> {
        rgd <span style="color: #4c83ff;">&lt;-</span> rg
        prdKPG <span style="color: #4c83ff;">&lt;-</span> prdWXy+ ((solve(rgd) %*% rg %*% (yobs- prdKP1)))
    }
    prdKPG
}
</pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> How it works</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> Choosing a type of predictor</h3>
<div class="outline-text-3" id="text-4-1">
<p>
Our new <code>R</code> function for spatial predictions &#x2013; called <code>sppred</code> for
the moment &#x2013; admits a first additional argument <code>predictor</code> that
specify the computed predictor. Knowing that predictors
corresponding to larger information sets are more complex,
flexibility is needed to let the user makes its own trade-off
between simplicity and prediction efficiency. The following table
define the available predictors.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 1:</span> The available values for the new <code>predictor</code> argument</caption>

<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left"><code>predictor</code></th>
<th scope="col" class="left">label</th>
<th scope="col" class="left">equation (see XX)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">"1"</td>
<td class="left">minimum information</td>
<td class="left">(XX)</td>
</tr>

<tr>
<td class="left">"2"</td>
<td class="left">heuristic BLUP</td>
<td class="left">(XX)</td>
</tr>

<tr>
<td class="left">"3"</td>
<td class="left">BLUP</td>
<td class="left">(XX)</td>
</tr>

<tr>
<td class="left">"4"</td>
<td class="left">heuristic data</td>
<td class="left">(XX)</td>
</tr>
</tbody>
</table>

<p>
The <code>predictor</code> 4 is currently the default for IS prediction in
<code>predict.sarlm</code> (it corresponds to the predictor KP4 for lag models
and KP5 for error models).
</p>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> Specifying</h3>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> General structure, usual checks, and IS predictions</h3>
<div class="outline-text-3" id="text-4-3">
<p>
Here the code, for the inverse integrating directly the code from
powerWeigths?
</p>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4"><span class="section-number-3">4.4</span> The predictors 1 for OS predictions</h3>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> The <code>boston</code> example</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> The spatial samples</h3>
<div class="outline-text-3" id="text-5-1">
<p>
We use here the <code>boston</code> dataset, available from the <code>spdep</code>
package (Bivand 2014). It consists in XX. From the whole sample, we
draw randomly 211 observations from 250 drawn of a uniform
distribution and dropping duplicated units. This allows to
distinguish two sample: IS and OS.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #4c83ff;">library</span>(spdep) ; data(boston) ; <span style="color: #4c83ff;">library</span>(rgdal)
bst.sp <span style="color: #4c83ff;">&lt;-</span> readOGR(system.file(<span style="color: #61CE3C;">"etc/shapes"</span>, package= <span style="color: #61CE3C;">"spdep"</span>), <span style="color: #61CE3C;">"boston_tracts"</span>)
set.seed(84) ; cal <span style="color: #4c83ff;">&lt;-</span> unique(round(runif(250)* 500))
bst.sp$SMP <span style="color: #4c83ff;">&lt;-</span> <span style="color: #61CE3C;">"OS"</span> ; bst.sp$SMP[cal] <span style="color: #4c83ff;">&lt;-</span> <span style="color: #61CE3C;">"IS"</span>
ins.sp <span style="color: #4c83ff;">&lt;-</span> subset(bst.sp, bst.sp$SMP== <span style="color: #61CE3C;">"IS"</span>)
ots.sp <span style="color: #4c83ff;">&lt;-</span> subset(bst.sp, bst.sp$SMP== <span style="color: #61CE3C;">"OS"</span>)
cbind(<span style="color: #61CE3C;">"ALL"</span>= dim(bst.sp), <span style="color: #61CE3C;">"IN SMP"</span>= dim(ins.sp), <span style="color: #61CE3C;">"OUT SMP"</span>= dim(ots.sp))
</pre>
</div>

<pre class="example">
OGR data source with driver: ESRI Shapefile 
Source: "/home/jsay/R/x86_64-pc-linux-gnu-library/3.0/spdep/etc/shapes", layer: "boston_tracts"
with 506 features and 21 fields
Feature type: wkbPolygon with 2 dimensions
     ALL IN-SMP OUT-SMP
[1,] 506    211     295
[2,]  22     22      22
</pre>

<p>
Spatial units without neighbors are kept in these spatial
data.frames.
</p>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> Neighborhood relationships</h3>
<div class="outline-text-3" id="text-5-2">
<p>
The following code use the function <code>nbsubset</code> described in
Appendix XX and tangled in the file <code>spsubset.R</code>. As it is shown by
the following Figure XX, this function allows to compute the <code>nb</code>
equivalent to the spatial weight matrix \(W_I\), \(W_O\), \(W_{IO}\) and
\(W_{OI}\). The logic behind <code>nbsubset</code> is rather different than the
classical <code>subset.nb</code> function because some absent units have to be
referred by present units. So we do not change the dimension of the
<code>nb</code> matrix, we put some 0 instead but this leads to some problems
to compute the spatial weights after (see the commentaries in
Appendix <a href="#SFL">7.2</a>).
</p>

<div class="org-src-container">

<pre class="src src-R" id="Lst:SWB"><span style="color: #4c83ff;">source</span>(<span style="color: #61CE3C;">"spsubset.R"</span>)
bst.nb <span style="color: #4c83ff;">&lt;-</span> poly2nb(bst.sp) ; bst.lw <span style="color: #4c83ff;">&lt;-</span> nb2listw(bst.nb)
WII <span style="color: #4c83ff;">&lt;-</span> nbsubset(bst.nb, bst.sp$SMP== <span style="color: #61CE3C;">"IS"</span>, target= bst.sp$SMP== <span style="color: #61CE3C;">"IS"</span>)
WIO <span style="color: #4c83ff;">&lt;-</span> nbsubset(bst.nb, bst.sp$SMP== <span style="color: #61CE3C;">"IS"</span>, target= bst.sp$SMP== <span style="color: #61CE3C;">"OS"</span>)
WOI <span style="color: #4c83ff;">&lt;-</span> nbsubset(bst.nb, bst.sp$SMP== <span style="color: #61CE3C;">"OS"</span>, target= bst.sp$SMP== <span style="color: #61CE3C;">"IS"</span>)
WOO <span style="color: #4c83ff;">&lt;-</span> nbsubset(bst.nb, bst.sp$SMP== <span style="color: #61CE3C;">"OS"</span>, target= bst.sp$SMP== <span style="color: #61CE3C;">"OS"</span>)
par(mar= c(0, 0, 0, 0)) ; plot(bst.sp, lwd= 5)
plot(ots.sp, col= <span style="color: #61CE3C;">"grey70"</span>, add= <span style="color: #D8FA3C;">TRUE</span>, border= <span style="color: #D8FA3C;">FALSE</span>)
plot(ins.sp, col= <span style="color: #61CE3C;">"grey30"</span>, add= <span style="color: #D8FA3C;">TRUE</span>, border= <span style="color: #D8FA3C;">FALSE</span>)
plot(bst.nb, coordinates(bst.sp), add= T, col= <span style="color: #61CE3C;">"black"</span> , pch= 20, cex= .2)
plot(WII, coordinates(bst.sp), add= T, col= <span style="color: #61CE3C;">"green"</span>, pch= 20, cex= .2)
plot(WIO, coordinates(bst.sp), add= T, col= <span style="color: #61CE3C;">"blue"</span> , pch= 20, cex= .2)
plot(WOO, coordinates(bst.sp), add= T, col= <span style="color: #61CE3C;">"red"</span>  , pch= 20, cex= .2)
legend(<span style="color: #61CE3C;">"topleft"</span>, col= c(<span style="color: #61CE3C;">"blue"</span>, <span style="color: #61CE3C;">"green"</span>, <span style="color: #61CE3C;">"red"</span>), lwd= 1.5,
       c(<span style="color: #61CE3C;">"PRD NBH"</span>, <span style="color: #61CE3C;">"IS NBH"</span>, <span style="color: #61CE3C;">"OS NBH"</span>), bty= <span style="color: #61CE3C;">"n"</span>, cex= 1.25)
legend(<span style="color: #61CE3C;">"right"</span>, fill= c(<span style="color: #61CE3C;">"grey30"</span>, <span style="color: #61CE3C;">"grey70"</span>),
       c(<span style="color: #61CE3C;">"IN-SAMPLE"</span>, <span style="color: #61CE3C;">"OUT-OF-SAMPLE"</span>), bty= <span style="color: #61CE3C;">"n"</span>, cex= 1.25)
</pre>
</div>

<p>
<a href="Figures/SpWeigthBoston.pdf">Figures/SpWeigthBoston.pdf</a>
</p>

<p>
From a first order neighboring point of view, the symmetry of the
matrix produce a clear distinction between the spatial
relationships. They are identified through different colors
according to&#x2026; The green links are of central interest for
information transmission between units. Be careful about the island
that present yellow links (see at the bottom right).
</p>

<p>
LES ILOTS "IS" NE PEUVENT PAS ETRE UTILISES POUR ESTIMER LE MODELE
MAIS PEUVENT ETRE UTILE POUR PREDIRE
</p>

<p>
Il ne faut pas que je change les id et donc la dimension il faut
simplement mettre de zéro? Et ensuite à partir d'autres subsets sur
cette matrice on devrait obtenir la bonne dimension. Dans cette
deuxième étape on devrait alors enlever les ilots.
</p>

<p>
Une autre possibilité serait de spécifier la matrice avec tout le
monde, la traduire en W et sélectionner les lignes et les colonnes
qui nous intéressent.
</p>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3"><span class="section-number-3">5.3</span> Estimating the models</h3>
<div class="outline-text-3" id="text-5-3">
<p>
We estimate on the IS sample the 6 spatial econometric models from
the <code>spdep</code> package, with the classical specification presented in
Bivand (2002). Before the estimation (and to be OK with the
computation of spatial weights) we have to drop some units without
neighbors with the help of the <code>card</code> function.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">DROP OUT THE UNITS WITHOUT NEIGHBORS</span>
ins.lw <span style="color: #4c83ff;">&lt;-</span> subset(bst.lw, card(WII)!= 0) 
inz.sp <span style="color: #4c83ff;">&lt;-</span> subset(bst.sp, card(WII)!= 0)
<span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">DEFINE THE MODEL SPECIFICATION</span>
eqn.bst <span style="color: #4c83ff;">&lt;-</span> log(CMEDV)~ CRIM    + ZN + INDUS   + CHAS    + I(NOX^2)+
                       I(RM^2) + AGE+ log(DIS)+ log(RAD)+ TAX     +
                       PTRATIO + B  + log(LSTAT)
<span style="color: #8B8989; font-style: italic;">## </span><span style="color: #8B8989; font-style: italic;">ESTIMATE THE MODELS AND REPORT THE AICs</span>
sem <span style="color: #4c83ff;">&lt;-</span> errorsarlm(eqn.bst, data= inz.sp, ins.lw, method= <span style="color: #61CE3C;">"Matrix"</span>)
sxm <span style="color: #4c83ff;">&lt;-</span> errorsarlm(eqn.bst, data= inz.sp,
                  ins.lw, etype= <span style="color: #61CE3C;">"emixed"</span>   , method= <span style="color: #61CE3C;">"Matrix"</span>)
sar <span style="color: #4c83ff;">&lt;-</span> lagsarlm(  eqn.bst, data= inz.sp, ins.lw, method= <span style="color: #61CE3C;">"Matrix"</span>)
sdm <span style="color: #4c83ff;">&lt;-</span> lagsarlm(  eqn.bst, data= inz.sp,
                  ins.lw,  type= <span style="color: #61CE3C;">"mixed"</span>    , method= <span style="color: #61CE3C;">"Matrix"</span>)
sac <span style="color: #4c83ff;">&lt;-</span> sacsarlm(  eqn.bst, data= inz.sp, ins.lw, method= <span style="color: #61CE3C;">"Matrix"</span>)
smc <span style="color: #4c83ff;">&lt;-</span> sacsarlm(  eqn.bst, data= inz.sp,
                  ins.lw,  type= <span style="color: #61CE3C;">"sacmixed"</span> , method= <span style="color: #61CE3C;">"Matrix"</span>)
spmod <span style="color: #4c83ff;">&lt;-</span> list(sem= sem, sxm= sxm, sar= sar, sdm= sdm, sac= sac, smc= smc)
data.frame(lapply(spmod, AIC))
</pre>
</div>

<pre class="example">
        sem       sxm       sar       sdm       sac       smc
1 -132.4525 -164.1509 -139.7872 -163.6526 -142.8058 -163.1881
</pre>

<p>
The SXM is the more parsimonious in terms of AC 
</p>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4"><span class="section-number-3">5.4</span> Predicting for in-sample</h3>
<div class="outline-text-3" id="text-5-4">
<p>
We next compute the RMSE for each model \(\times\) predictor
combination.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #4c83ff;">source</span>(<span style="color: #61CE3C;">"sppred.R"</span>) ; <span style="color: #4c83ff;">library</span>(plyr)
<span style="color: #ff1493;">rmse</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span>(prd, mod) sqrt(mean(I(prd- mod$y)^2))
RMSE <span style="color: #4c83ff;">&lt;-</span> data.frame(<span style="color: #61CE3C;">"X"</span>=   ldply(spmod, <span style="color: #FBDE2D;">function</span>(x)
                           rmse(sppred(x, condset= <span style="color: #61CE3C;">"X"</span>), x))$V1,
              <span style="color: #61CE3C;">"XW"</span>=  ldply(spmod, <span style="color: #FBDE2D;">function</span>(x)
                           rmse(sppred(x, condset= <span style="color: #61CE3C;">"XW"</span>), x))$V1,
              <span style="color: #61CE3C;">"KP1"</span>= ldply(spmod, <span style="color: #FBDE2D;">function</span>(x) rmse(sppred(x), x))$V1,
              <span style="color: #61CE3C;">"XWy"</span>= ldply(spmod, <span style="color: #FBDE2D;">function</span>(x)
                           rmse(sppred(x, condset= <span style="color: #61CE3C;">"XWy"</span>), x))$V1,
              <span style="color: #61CE3C;">"LSP"</span>= ldply(spmod, <span style="color: #FBDE2D;">function</span>(x)
                           rmse(sppred(x, blup= <span style="color: #61CE3C;">"LSP"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>), x))$V1,
              <span style="color: #61CE3C;">"KP2"</span>= ldply(spmod, <span style="color: #FBDE2D;">function</span>(x)
                           rmse(sppred(x, blup= <span style="color: #61CE3C;">"KP2"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>), x))$V1,
              <span style="color: #61CE3C;">"KP3"</span>= ldply(spmod, <span style="color: #FBDE2D;">function</span>(x)
                           rmse(sppred(x, blup= <span style="color: #61CE3C;">"KP3"</span>, loo= <span style="color: #D8FA3C;">TRUE</span>), x))$V1)
row.names(RMSE) <span style="color: #4c83ff;">&lt;-</span> names(spmod) ; round(RMSE, 4)
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption class="t-above"><span class="table-number">Table 2:</span> The RMSE from IS sample for the 6 spatial models and 7 predictors</caption>

<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />

<col  class="right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="right">X</th>
<th scope="col" class="right">XW</th>
<th scope="col" class="right">KP1</th>
<th scope="col" class="right">XWy</th>
<th scope="col" class="right">LSP</th>
<th scope="col" class="right">KP2</th>
<th scope="col" class="right">KP3</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">sem</td>
<td class="right">0.2124</td>
<td class="right">0.2124</td>
<td class="right">0.2124</td>
<td class="right">0.1449</td>
<td class="right">0.137</td>
<td class="right">0.185</td>
<td class="right">0.2015</td>
</tr>

<tr>
<td class="left">sxm</td>
<td class="right">0.9832</td>
<td class="right">0.1661</td>
<td class="right">0.1661</td>
<td class="right">0.1292</td>
<td class="right">0.1221</td>
<td class="right">0.1464</td>
<td class="right">0.1539</td>
</tr>

<tr>
<td class="left">sar</td>
<td class="right">1.3541</td>
<td class="right">1.3541</td>
<td class="right">0.1846</td>
<td class="right">0.1504</td>
<td class="right">0.1409</td>
<td class="right">0.1423</td>
<td class="right">0.1119</td>
</tr>

<tr>
<td class="left">sdm</td>
<td class="right">1.5871</td>
<td class="right">1.5536</td>
<td class="right">0.1627</td>
<td class="right">0.1306</td>
<td class="right">0.1231</td>
<td class="right">0.128</td>
<td class="right">0.1127</td>
</tr>

<tr>
<td class="left">sac</td>
<td class="right">0.941</td>
<td class="right">0.941</td>
<td class="right">0.1899</td>
<td class="right">0.3152</td>
<td class="right">0.1373</td>
<td class="right">0.327</td>
<td class="right">0.302</td>
</tr>

<tr>
<td class="left">smc</td>
<td class="right">1.9819</td>
<td class="right">0.692</td>
<td class="right">0.17</td>
<td class="right">0.4797</td>
<td class="right">0.1208</td>
<td class="right">0.4632</td>
<td class="right">0.4714</td>
</tr>
</tbody>
</table>

<p>
The results are intriguing, the fact that KP3 does not always
perform best is fuzzy.
</p>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5"><span class="section-number-3">5.5</span> Recovering impact measures</h3>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6"><span class="section-number-3">5.6</span> Recovering trend and signal terms</h3>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> Summary</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> Changes relative to <code>predict.sarlm</code></h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>Implement predictions for SARAR and Mixed SARAR models from
respectively <code>sac</code> and <code>sacmixed</code> classes.
</li>
<li>Compute BLUP and almost BLUP spatial predictors
</li>
<li>About the in-sample / out of sample structure (<code>newdata</code>)
</li>
<li>About the distinction between trend and signal
</li>
<li>The simplification of the in-sample predictions
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> About the intercept</h3>
<div class="outline-text-3" id="text-6-2">
<p>
We change the scan of the intercept, in particular in presence of
\(WX\) in the regression. If \(W\) is row standardized, we have to drop
the intercept to avoid collinearity. The initial function add the
constant at the end of the computations, we only drop the intercept
in the presence of \(WX\).
</p>


<div id="bibliography">
<h2>References</h2>

</div>


<p><a name="Anse88"></a>

<b>Anselin, L.</b> (1988). <em>Spatial Econometrics: Methods and Models</em>,
   <em>4</em>. Springer, Boston.
[&nbsp;<a href="BibPrd_bib.html#Anse88">bib</a>&nbsp;]

</p>

<p><a name="Biva14"></a>

<b>Bivand, R.</b> (2014). <b>spdep</b>: Spatial dependence: Weighting
  schemes, statistics and models. R package version 0.5-71.
[&nbsp;<a href="BibPrd_bib.html#Biva14">bib</a>&nbsp;| 
<a href="http://CRAN.R-project.org/package=spdep">http</a>&nbsp;]

</p>

<p><a name="BCHo07"></a>

<b>Bourassa, S.&nbsp;C., E.&nbsp;Cantoni and M.&nbsp;Hoesli</b> (2007). Spatial dependence,
  housing submarkets, and house price prediction. <em>The Journal of Real
  Estate Finance and Economics</em> 35: 143-160.
[&nbsp;<a href="BibPrd_bib.html#BCHo07">bib</a>&nbsp;]

</p>

<p><a name="COrd73"></a>

<b>Cliff, A.&nbsp;D. and J.&nbsp;K. Ord</b> (1973). <em>Spatial Autocorrelation</em>,
  <em>5</em>. Pion, London.
[&nbsp;<a href="BibPrd_bib.html#COrd73">bib</a>&nbsp;]

</p>

<p><a name="COrd81"></a>

<b>Cliff, A.&nbsp;D. and J.&nbsp;K. Ord</b> (1981). <em>Spatial Processes, Models &amp;
  Applications</em>. Pion, London.
[&nbsp;<a href="BibPrd_bib.html#COrd81">bib</a>&nbsp;]

</p>

<p><a name="CCas93"></a>

<b>Cressie, N.&nbsp;A. and N.&nbsp;A. Cassie</b> (1993). <em>Statistics for Spatial
  Data</em>,   <em>900</em>. Wiley New York.
[&nbsp;<a href="BibPrd_bib.html#CCas93">bib</a>&nbsp;]

</p>

<p><a name="Gold62"></a>

<b>Goldberger, A.&nbsp;S.</b> (1962). Best linear unbiased prediction in the
  generalized linear regression model. <em>Journal of the American Statistical
  Association</em> 57: 369-375.
[&nbsp;<a href="BibPrd_bib.html#Gold62">bib</a>&nbsp;]

</p>

<p><a name="KPru07"></a>

<b>Kelejian, H.&nbsp;H. and I.&nbsp;R. Prucha</b> (2007). The relative efficiencies of
  various predictors in spatial econometric models containing spatial lags.
  <em>Regional Science and Urban Economics</em> 37: 363-374.
[&nbsp;<a href="BibPrd_bib.html#KPru07">bib</a>&nbsp;]

</p>

<p><a name="LPac04"></a>

<b>LeSage, J.&nbsp;P. and R.&nbsp;K. Pace</b> (2004). Models for spatially dependent
  missing data. <em>The Journal of Real Estate Finance and Economics</em> 29:
  233-254.
[&nbsp;<a href="BibPrd_bib.html#LPac04">bib</a>&nbsp;]

</p>

<p><a name="PLes08"></a>

<b>Pace, R.&nbsp;K. and J.&nbsp;P. LeSage</b> (2008). Spatial econometric models,
  prediction. In <b>Shekhar, S. and H.&nbsp;Xiong</b> (eds), <em>Encyclopedia of
  Geographical Information Science</em>. 10.1007/978-0-387-35973-1:
  Springer-Verlag.
[&nbsp;<a href="BibPrd_bib.html#PLes08">bib</a>&nbsp;]

</p>

<p><a name="TALG13"></a>

<b>Thomas-Agnan, C., T.&nbsp;Laurent and M.&nbsp;Goulard</b> (2013). About
  predictions in spatial autoregressive models: Optimal and almost optimal
  strategies. TSE Working Papers 13-452, Toulouse School of Economics (TSE).
[&nbsp;<a href="BibPrd_bib.html#TALG13">bib</a>&nbsp;| 
<a href="http://ideas.repec.org/p/tse/wpaper/27788.html">.html</a>&nbsp;]

</p>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> Appendix</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> Subset function for <code>nb</code> objects</h3>
<div class="outline-text-3" id="text-7-1">
<p>
The following function <code>nbsubset</code> is a first step to decompose the
spatial weight matrix, in order to compute ex-sample predictions.
Based on the function <code>subset.nb</code> from the package <code>spdep</code>, the
<code>subset</code> argument is replaced by two new arguments: <code>focal</code> and
<code>target</code>.  In raw matrix terms, <code>focal</code> corresponds to rows and
<code>target</code> corresponds to columns.  As <code>subset</code>, these arguments have
to be logical vector of the same size that the <code>nb</code> object.  Note
that we can recover the same <code>nb</code> relations from the <code>subset.nb</code> by
putting the same logical vector both for <code>focal</code> and <code>target</code>. See
XX for an example of use.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">nbsubset</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span> (x, focal= rep(<span style="color: #D8FA3C;">TRUE</span>, length(x)),
                      target= rep(<span style="color: #D8FA3C;">TRUE</span>, length(x)), ...){
    <span style="color: #FBDE2D;">if</span> (!inherits(x, <span style="color: #61CE3C;">"nb"</span>)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"not a neighbours list"</span>)
    <span style="color: #FBDE2D;">if</span> (!is.logical(focal)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"subset not a logical vector"</span>)
    <span style="color: #FBDE2D;">if</span> (!is.logical(target)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"target not a logical vector"</span>)
    n <span style="color: #4c83ff;">&lt;-</span> length(x)
    <span style="color: #FBDE2D;">if</span> (n != length(focal)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"neighours list and subset focal different lengths"</span>)
    <span style="color: #FBDE2D;">if</span> (n != length(target)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"neighours list and subset target different lengths"</span>)
    tgt.ids <span style="color: #4c83ff;">&lt;-</span> seq(1, n)[ target]
    x <span style="color: #4c83ff;">&lt;-</span> sym.attr.nb(x)
    xattrs <span style="color: #4c83ff;">&lt;-</span> names(attributes(x))
    z <span style="color: #4c83ff;">&lt;-</span> ifelse(focal, x, 0L)
    <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> seq(along= 1: n)[ focal]){
        zi <span style="color: #4c83ff;">&lt;-</span> z[[ i]]
        zn <span style="color: #4c83ff;">&lt;-</span> zi[zi %<span style="color: #FBDE2D;">in</span>% tgt.ids]
        <span style="color: #FBDE2D;">if</span> (length(zn)== 0) z[[ i]] <span style="color: #4c83ff;">&lt;-</span> 0L
        <span style="color: #FBDE2D;">else</span> z[[ i]] <span style="color: #4c83ff;">&lt;-</span> sort(unique(zn))
    }
    attr(z, <span style="color: #61CE3C;">"region.id"</span>) <span style="color: #4c83ff;">&lt;-</span>attr(x, <span style="color: #61CE3C;">"region.id"</span>)
    <span style="color: #FBDE2D;">for</span> (i <span style="color: #FBDE2D;">in</span> 1:length(xattrs)) {
        <span style="color: #FBDE2D;">if</span> (xattrs[i] != <span style="color: #61CE3C;">"region.id"</span>) 
            attr(z, xattrs[i]) <span style="color: #4c83ff;">&lt;-</span> attr(x, xattrs[i])
    }
    z <span style="color: #4c83ff;">&lt;-</span> sym.attr.nb(z)
    z
}
</pre>
</div>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> <a id="SFL" name="SFL"></a> Subset function for <code>listw</code> objects</h3>
<div class="outline-text-3" id="text-7-2">
<p>
Below the <code>lwsubset</code> function, that is the symmetric of previous
<code>nbsubset</code> function for the <code>listw</code> objects. The code is not
finished because of the function <code>nb2listw</code> that cannot admits
units without neighbors and the presence of rectangular <code>nb</code>
relationships from <code>nbsubset</code>.
</p>

<div class="org-src-container">

<pre class="src src-R"><span style="color: #ff1493;">lwsubset</span> <span style="color: #4c83ff;">&lt;-</span> <span style="color: #FBDE2D;">function</span> (x, focal= rep(<span style="color: #D8FA3C;">TRUE</span>, length(x)),
                      target= rep(<span style="color: #D8FA3C;">TRUE</span>, length(x)), zero.policy = <span style="color: #D8FA3C;">NULL</span>, ...){
    <span style="color: #FBDE2D;">if</span> (!inherits(x, <span style="color: #61CE3C;">"listw"</span>)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"not a weights list"</span>)
    <span style="color: #FBDE2D;">if</span> (is.null(zero.policy)) 
        zero.policy <span style="color: #4c83ff;">&lt;-</span> get(<span style="color: #61CE3C;">"zeroPolicy"</span>, envir = .spdepOptions)
    stopifnot(is.logical(zero.policy))
    <span style="color: #FBDE2D;">if</span> (!is.logical(focal)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"focal not a logical vector"</span>)
    <span style="color: #FBDE2D;">if</span> (!is.logical(target)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"target not a logical vector"</span>)
    nb <span style="color: #4c83ff;">&lt;-</span> x$neighbours
    vlist <span style="color: #4c83ff;">&lt;-</span> x$weights
    <span style="color: #FBDE2D;">if</span> (attr(vlist, <span style="color: #61CE3C;">"mode"</span>) != <span style="color: #61CE3C;">"binary"</span>) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"Not yet able to subset general weights lists"</span>)
    style <span style="color: #4c83ff;">&lt;-</span> x$style
    n <span style="color: #4c83ff;">&lt;-</span> length(nb)
    <span style="color: #FBDE2D;">if</span> (n != length(focal)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"neighbours list and focal vector different lengths"</span>)
    <span style="color: #FBDE2D;">if</span> (n != length(target)) 
        <span style="color: #FBDE2D;">stop</span>(<span style="color: #61CE3C;">"neighbours list and target vector different lengths"</span>)
    subnb <span style="color: #4c83ff;">&lt;-</span> nbsubset(nb, focal, target)
    sublistw <span style="color: #4c83ff;">&lt;-</span> nb2listw(neighbours= subnb, glist= <span style="color: #D8FA3C;">NULL</span>,
                         style= style, zero.policy= zero.policy)
    sublistw
}
</pre>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" name="fn.1" class="footnum" href="#fnr.1">1</a></sup> <p class="footpara">
This terminology comes from LeSage and Pace (2009) and Bivand
(2014). This model is also called spatial autoregressive model with
autoregressive disturbances, SARAR(1,1), by Kelejian and Prucha
(1998). The notations of spatial lag coefficients also depends on
authors, we adopt here those of the <b>R</b> package <code>spdep</code> (Bivand,
2014).
</p></div>

<div class="footdef"><sup><a id="fn.2" name="fn.2" class="footnum" href="#fnr.2">2</a></sup> <p class="footpara">
Does the geo-statistical literature is concerned with marginal
effects of covariates? Somme papers?
</p></div>

<div class="footdef"><sup><a id="fn.3" name="fn.3" class="footnum" href="#fnr.3">3</a></sup> <p class="footpara">
In particular, it could be of interest to predict outcome
values for units with known \(y\) for diagnostic, goodness-of-fit
purposes or computations of marginal effects of covariates.
</p></div>


</div>
</div></div>
</body>
</html>
